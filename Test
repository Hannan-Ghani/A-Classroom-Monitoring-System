import com.amazonaws.services.glue.GlueContext
import com.amazonaws.services.glue.util.Job
import org.apache.spark.SparkContext
import org.apache.spark.sql.SparkSession
import org.apache.spark.sql.DataFrame
import com.amazonaws.services.glue.util.GlueArgParser
import org.apache.spark.sql.functions._
import org.apache.log4j.Logger

object CleanseCaseClass {

  def main(sysArgs: Array[String]): Unit = {
    // Initialize Glue and Spark context
    val spark: SparkContext = new SparkContext()
    val glueContext: GlueContext = new GlueContext(spark)
    val sparkSession: SparkSession = glueContext.getSparkSession
    import sparkSession.implicits._

    // Logger setup
    val logger: Logger = Logger.getLogger(this.getClass.getName)  // Updated to avoid ambiguity

    // Get the S3 config path from Glue job parameters
    val args = GlueArgParser.getResolvedOptions(sysArgs, Seq("s3ConfigPath").toArray)
    val s3ConfigPath = args("s3ConfigPath")

    // Read the configuration file from S3
    val configDF = sparkSession.read.text(s3ConfigPath)

    // Convert the config DataFrame into a Map of key-value pairs
    val configMap = configDF.collect().map { row =>
      val split = row.getString(0).split("=")
      (split(0), split(1))
    }.toMap

    // Extract input and output paths from the config file
    val inputSourcePath = configMap("inputSourcePath")
    val inputTargetPath = configMap("inputTargetPath")
    val outputCombinedExceptPath = configMap("outputCombinedExceptPath")

    // =======================
    // PART 1: Narrative Validation
    // =======================

    // Step 1: Read the transaction source Parquet file from the inputSourcePath in the config file
    val transactionSource: DataFrame = sparkSession.read.parquet(inputSourcePath)
      .filter($"transaction_date" > "2023-01-01" && $"transaction_date" < "2023-01-31")

    // Step 2: Read the case class DataFrame from the inputTargetPath in the config file
    val caseClass: DataFrame = sparkSession.read.parquet(inputTargetPath)

    // Define the columns you expect to compare
    val expectedColumns = Seq(
      "aBic", "aIban", "aBank", "aBankCountry", "aBankCountryIso3", "aAddress", "aParsedAddress", "aName",
      "bBranchUniqueId", "bBic", "bIban", "bBank", "bBankCountry", "bBankCountryIso3", "bAddress", "bParsedAddress", "bName",
      "aCounterpartyBankBic", "aCounterpartyBankName", "aCounterpartyBankCountry", "aCounterpartyBankCountryIso3",
      "bCounterpartyBankBic", "bCounterpartyBankName", "bCounterpartyBankCountry", "bCounterpartyBankCountryIso3",
      "interBankBic", "interBankName", "interBankCountry", "interBankCountryIso3",
      "reference", "additionalReference", "format", "crossborder", "charges", "sanctionsStatus", "paymentsStatus",
      "aAccountNumber", "amountUsd", "aAccountOpenDate", "bAccountOpenDate", "aggregatedTransactionDirectionATeB"
    )

    // Get the list of columns in the caseClass DataFrame
    val existingColumns = caseClass.columns.toSet

    // Find which columns are missing
    val missingColumns = expectedColumns.filterNot(existingColumns.contains)

    // Log missing columns
    if (missingColumns.nonEmpty) {
      logger.warn(s"Missing columns: ${missingColumns.mkString(", ")}")
    }

    // Filter out missing columns and select only existing columns
    val validColumns = expectedColumns.filter(existingColumns.contains)

    // Select the existing columns from the DataFrame for comparison
    val target = caseClass.select(validColumns.map(col): _*).distinct()

    // Show the valid target data
    target.show(2, false)

    // =======================
    // PART 2: Narrative Validation (Example of Comparison)
    // =======================

    // Clean the narrative field in source: Replace "**" and "***" with null values
    val source_Narrative = transactionSource.withColumn(
      "NARRATIVE", 
      when(trim($"NARRATIVE") === "**", null)
        .when(trim($"NARRATIVE") === "***", null)
        .otherwise($"NARRATIVE")
    ).select($"TRANSACTION_ID", $"NARRATIVE")

    // Select the corresponding fields from the target DataFrame (caseClass)
    val target_Narrative = caseClass.select($"transactionId", $"narrative")

    // Compare source to target (Narrative validation)
    source_Narrative.exceptAll(target_Narrative).show(2, false)

    // Compare target to source (Narrative validation)
    target_Narrative.exceptAll(source_Narrative).show(2, false)

    // Commit the Glue job to mark it as successfully completed
    Job.commit()
  }
}