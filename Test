// =======================
// PART 6: Combined Validation (accountNumberCleansed, sort codes, amountLocal, transactionUniqueId, etc.)
// =======================
val combinedValidationColumns = Seq(
  "aAccountNumberCleansed", "aSortCodeCleansed", 
  "bAccountNumberCleansed", "bSortCodeCleansed"
)

// Filter out any missing columns before performing the validation
val existingCombinedValidationColumns = filterExistingColumns(caseClass, combinedValidationColumns)

// Only apply the filter if there are valid columns
val combinedValidation = if (existingCombinedValidationColumns.nonEmpty) {
  caseClass
    .select(existingCombinedValidationColumns.map(col): _*)
    .filter(
      existingCombinedValidationColumns.map(c => col(c).isNotNull).reduce(_ || _)
    )
} else {
  logger.warn("No valid columns found for combined validation")
  sparkSession.emptyDataFrame
}

// Amount Local Validation
val sourceAmountLocal = transactionSource.select($"TRANSACTION_ID", $"ORIGINAL_AMOUNT")
val targetAmountLocal = caseClass.select($"transactionId", $"amountLocal")
val amountLocalValidation = sourceAmountLocal.exceptAll(targetAmountLocal)

// Transaction Unique ID Validation
val sourceTransactionUniqueId = transactionSource
  .withColumn("transactionUniqueId", concat(col("TRANSACTION_ID"), lit("//"), col("EFF_START_DATE")))
  .select($"TRANSACTION_ID", $"transactionUniqueId")

val targetTransactionUniqueId = caseClass.select($"transactionId", $"transactionUniqueId")
val transactionUniqueIdValidation = sourceTransactionUniqueId.exceptAll(targetTransactionUniqueId)

// A Account Number Validation
val sourceAAccountNumber = caseClass
  .withColumn(
    "aAccountNumber",
    when(substring($"aAccountId", 1, 5) isin ("UKUBA"), substring($"aAccountId", 9, 8))
      .when(substring($"aAccountId", 1, 5) isin ("UKGTS"), substring($"aAccountId", 8, 9))
      .otherwise(null)
  )
  .select($"transactionId", $"aAccountNumber")

val targetAAccountNumber = caseClass.select($"transactionId", $"aAccountNumber")
val aAccountNumberValidation = sourceAAccountNumber.exceptAll(targetAAccountNumber)

// B Account Number Validation
val sourceBAccountNumber = caseClass
  .withColumn(
    "bAccountNumber",
    when(substring($"bAccountId", 1, 5) isin ("UKUBA"), substring($"bAccountId", 9, 8))
      .when(substring($"bAccountId", 1, 5) isin ("UKGTS"), substring($"bAccountId", 8, 9))
      .otherwise(null)
  )
  .select($"transactionId", $"bAccountNumber")

val targetBAccountNumber = caseClass.select($"transactionId", $"bAccountNumber")
val bAccountNumberValidation = sourceBAccountNumber.exceptAll(targetBAccountNumber)

// Union all combined validations
val finalCombinedValidation = combinedValidation
  .union(amountLocalValidation)
  .union(transactionUniqueIdValidation)
  .union(aAccountNumberValidation)
  .union(bAccountNumberValidation)

val combinedValidationOutputPath = s"${outputBasePath}/combined_validation/"
finalCombinedValidation.write.mode("overwrite").parquet(combinedValidationOutputPath)