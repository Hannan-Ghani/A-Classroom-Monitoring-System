def applyDirectColumnValidation(
    sourceCols: String,
    targetCols: String,
    transactionSource: DataFrame,
    caseClass: DataFrame
)(implicit spark: SparkSession): List[String] = {
  import spark.implicits._

  // Identify transaction ID columns dynamically
  val sourceTransactionIdCol = transactionSource.columns.find(_.equalsIgnoreCase("TRANSACTION_ID"))
    .getOrElse(throw new NoSuchElementException("Transaction ID column 'TRANSACTION_ID' not found in source"))
  
  val targetTransactionIdCol = caseClass.columns.find(_.equalsIgnoreCase("transactionId"))
    .getOrElse(throw new NoSuchElementException("Transaction ID column 'transactionId' not found in target"))

  // Split and align column names
  val sourceColumns = sourceCols.split(",").map(_.trim).toSeq
  val targetColumns = targetCols.split(",").map(_.trim).toSeq

  // Ensure equal column counts
  if (sourceColumns.length != targetColumns.length) {
    throw new IllegalArgumentException("Source and target column lists must have the same length.")
  }

  // Select columns and rename for consistency
  val sourceSelected = transactionSource.select((Seq(col(sourceTransactionIdCol).as("col_0")) ++ 
    sourceColumns.zipWithIndex.map { case (colName, i) => col(colName).as(s"col_${i + 1}") }): _*)

  val targetSelected = caseClass.select((Seq(col(targetTransactionIdCol).as("col_0")) ++ 
    targetColumns.zipWithIndex.map { case (colName, i) => col(colName).as(s"col_${i + 1}") }): _*)

  // Perform `exceptAll` to find mismatches in either direction
  val sourceToTargetDiff = sourceSelected.exceptAll(targetSelected)
  val targetToSourceDiff = targetSelected.exceptAll(sourceSelected)

  // Collect transaction IDs from mismatches
  val unmatchedIds = (sourceToTargetDiff.select("col_0").as[String].collect() ++ 
                      targetToSourceDiff.select("col_0").as[String].collect()).distinct.toList

  unmatchedIds
}