import org.apache.spark.sql.SparkSession
import org.apache.spark.sql.functions._
import com.amazonaws.services.glue.util.GlueArgParser

object TransactionProcessing {

  def main(sysArgs: Array[String]): Unit = {
    // Initialize Spark Session
    val spark = SparkSession.builder.appName("TransactionProcessing").getOrCreate()

    // Import implicits for using $"column_name" syntax
    import spark.implicits._

    // Retrieve job parameters from Glue job configuration
    val args = GlueArgParser.getResolvedOptions(sysArgs, Seq(
      "SOURCE_PATH",           // S3 path for source data
      "TARGET_PATH",           // S3 path for target output
      "OUTPUT_PATH"            // S3 path for saving difference results
    ).toArray)

    // Extract parameter values
    val sourcePath = args("SOURCE_PATH")             // Path to source data
    val targetPath = args("TARGET_PATH")             // Path to target data
    val outputPath = args("OUTPUT_PATH")             // Path to save differences

    // Load source and target DataFrames from S3
    val source = spark.read.parquet(sourcePath)
    val target = spark.read.parquet(targetPath)

    // Select specific columns for comparison
    val sourceSelected = source.select(
      col("customer_key"),
      col("account_key"),
      col("execution_date"),
      col("transaction_date"),
      col("original_amount"),
      col("original_currency_code"),
      col("transaction_location"),
      col("transaction_country"),
      col("transaction_country_iso_code"),
      col("narrative"),
      col("shortnarrative"),
      col("transaction_type"),
      col("txn_direction"),
      col("txn_direction_desc"),
      col("transaction_type_desc"),
      col("amount"),
      col("transaction_id"),
      col("transaction_code"),
      col("transaction_code_desc"),
      col("sterling_equivalent"),
      col("int_dollar_equivalent"),
      col("transaction_routing_number"),
      col("external_account_number"),
      col("counterparty_customer_key"),
      col("counterparty_product_key"),
      col("counterparty_id"),
      col("source_transaction_id"),
      col("branch_key"),
      col("account_bucket"),
      col("jurisdiction"),
      col("screening_system"),
      col("source_system"),
      col("EFF_START_DATE")
    )

    val targetSelected = target.select(
      col("customer_key"),
      col("account_key"),
      col("execution_date"),
      col("transaction_date"),
      col("original_amount"),
      col("original_currency_code"),
      col("transaction_location"),
      col("transaction_country"),
      col("transaction_country_iso_code"),
      col("narrative"),
      col("shortnarrative"),
      col("transaction_type"),
      col("txn_direction"),
      col("txn_direction_desc"),
      col("transaction_type_desc"),
      col("amount"),
      col("transaction_id"),
      col("transaction_code"),
      col("transaction_code_desc"),
      col("sterling_equivalent"),
      col("int_dollar_equivalent"),
      col("transaction_routing_number"),
      col("external_account_number"),
      col("counterparty_customer_key"),
      col("counterparty_product_key"),
      col("counterparty_id"),
      col("source_transaction_id"),
      col("branch_key"),
      col("account_bucket"),
      col("jurisdiction"),
      col("screening_system"),
      col("source_system"),
      col("EFF_START_DATE")
    )

    // Find differences: Rows in source but not in target
    val differences = sourceSelected.exceptAll(targetSelected)

    // Save the differences to the specified S3 path as a Parquet file
    differences.write.mode("overwrite").parquet(s"$outputPath/differences")

    // Log a message based on the differences
    if (differences.isEmpty) {
      println(s"No differences found. The output is an empty table.")
    } else {
      println(s"Differences have been found and saved to: $outputPath/differences")
    }
  }
}