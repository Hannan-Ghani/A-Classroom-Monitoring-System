To integrate this next validation, which involves creating aAccountId and bAccountId based on txn_direction_desc, we will:
	1.	Add configuration support for each transformation.
	2.	Define parsing logic.
	3.	Create separate validation functions for aAccountId and bAccountId.
	4.	Implement a check for distinct values in transactionClass.

Let’s proceed step by step.

Step 1: Add Configuration Support

For aAccountId and bAccountId, add two separate sections in the configuration file specifying the columns and conditions for each transformation:

[a_account_id_transform]
txnDirectionColumn=txn_direction_desc
debitColumn=ACCOUNT_ID
creditColumn=COUNTERPARTY_ID

[b_account_id_transform]
txnDirectionColumn=txn_direction_desc
debitColumn=COUNTERPARTY_ID
creditColumn=ACCOUNT_ID

[transaction_class]
column=transactionClass

This configuration will specify:
	•	a_account_id_transform and b_account_id_transform for creating aAccountId and bAccountId, respectively.
	•	transaction_class to identify the column for distinct value checking.

Step 2: Add Parsing Logic to parseValidationConfig

Add cases to handle a_account_id_transform, b_account_id_transform, and transaction_class:

case "a_account_id_transform" =>
  val columns = trimmedLine.split(",").map(_.trim)
  if (columns.length == 3) {
    validationConfig += ("txnDirectionColumnForAAccount" -> columns(0))
    validationConfig += ("debitColumnForAAccountId" -> columns(1))
    validationConfig += ("creditColumnForAAccountId" -> columns(2))
  } else {
    println(s"Warning: Invalid format for aAccountId transform - $trimmedLine")
  }

case "b_account_id_transform" =>
  val columns = trimmedLine.split(",").map(_.trim)
  if (columns.length == 3) {
    validationConfig += ("txnDirectionColumnForBAccount" -> columns(0))
    validationConfig += ("debitColumnForBAccountId" -> columns(1))
    validationConfig += ("creditColumnForBAccountId" -> columns(2))
  } else {
    println(s"Warning: Invalid format for bAccountId transform - $trimmedLine")
  }

case "transaction_class" =>
  validationConfig += ("transactionClassColumn" -> trimmedLine)

This will add:
	•	Columns for aAccountId as txnDirectionColumnForAAccount, debitColumnForAAccountId, and creditColumnForAAccountId.
	•	Columns for bAccountId as txnDirectionColumnForBAccount, debitColumnForBAccountId, and creditColumnForBAccountId.
	•	The column name for transactionClass as transactionClassColumn.

Step 3: Define Validation Functions

validateAAccountId

This function applies the transformation for aAccountId and compares it with the target data:

def validateAAccountId(sourceDF: DataFrame, targetDF: DataFrame, configMap: Map[String, Any]): Seq[String] = {
  import sourceDF.sparkSession.implicits._

  val txnDirectionColumn = configMap.getOrElse("txnDirectionColumnForAAccount", "txn_direction_desc").toString
  val debitColumn = configMap.getOrElse("debitColumnForAAccountId", "ACCOUNT_ID").toString
  val creditColumn = configMap.getOrElse("creditColumnForAAccountId", "COUNTERPARTY_ID").toString

  val source = sourceDF.withColumn("aAccountId",
    when(col(txnDirectionColumn) === "DEBIT", col(debitColumn))
      .when(col(txnDirectionColumn) === "CREDIT", col(creditColumn))
      .otherwise(null)
  ).select($"transaction_id".as("transactionId"), $"aAccountId")

  val target = targetDF.select($"transactionId", $"aAccountId")

  val sourceToTargetDiff = source.exceptAll(target)
  val targetToSourceDiff = target.exceptAll(source)

  val sourceToTargetIds = sourceToTargetDiff.select($"transactionId").as[String].collect()
  val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

  Seq(
    "A Account ID Validation Differences:",
    s"Source to Target Differences: ${sourceToTargetIds.length} found with transaction IDs: ${sourceToTargetIds.mkString(", ")}",
    s"Target to Source Differences: ${targetToSourceIds.length} found with transaction IDs: ${targetToSourceIds.mkString(", ")}"
  )
}

validateBAccountId

Similarly, define a function for bAccountId transformation:

def validateBAccountId(sourceDF: DataFrame, targetDF: DataFrame, configMap: Map[String, Any]): Seq[String] = {
  import sourceDF.sparkSession.implicits._

  val txnDirectionColumn = configMap.getOrElse("txnDirectionColumnForBAccount", "txn_direction_desc").toString
  val debitColumn = configMap.getOrElse("debitColumnForBAccountId", "COUNTERPARTY_ID").toString
  val creditColumn = configMap.getOrElse("creditColumnForBAccountId", "ACCOUNT_ID").toString

  val source = sourceDF.withColumn("bAccountId",
    when(col(txnDirectionColumn) === "DEBIT", col(debitColumn))
      .when(col(txnDirectionColumn) === "CREDIT", col(creditColumn))
      .otherwise(null)
  ).select($"transaction_id".as("transactionId"), $"bAccountId")

  val target = targetDF.select($"transactionId", $"bAccountId")

  val sourceToTargetDiff = source.exceptAll(target)
  val targetToSourceDiff = target.exceptAll(source)

  val sourceToTargetIds = sourceToTargetDiff.select($"transactionId").as[String].collect()
  val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

  Seq(
    "B Account ID Validation Differences:",
    s"Source to Target Differences: ${sourceToTargetIds.length} found with transaction IDs: ${sourceToTargetIds.mkString(", ")}",
    s"Target to Source Differences: ${targetToSourceIds.length} found with transaction IDs: ${targetToSourceIds.mkString(", ")}"
  )
}

validateTransactionClass

This function checks for distinct values in transactionClass:

def validateTransactionClass(targetDF: DataFrame, configMap: Map[String, Any]): Seq[String] = {
  val transactionClassColumn = configMap.getOrElse("transactionClassColumn", "transactionClass").toString

  val distinctValues = targetDF.select(transactionClassColumn).distinct().collect().map(_.getString(0))
  
  Seq(s"Distinct values in $transactionClassColumn:", distinctValues.mkString(", "))
}

Step 4: Integrate the Functions into the Main Flow

In your main method, call each validation function after parsing the configuration:

validationResults = validationResults ++ validateAAccountId(transactionSource, caseClass, validationConfigMap)
validationResults = validationResults ++ validateBAccountId(transactionSource, caseClass, validationConfigMap)
validationResults = validationResults ++ validateTransactionClass(caseClass, validationConfigMap)

Example Configuration File

Include the new sections for aAccountId, bAccountId, and transactionClass:

[a_account_id_transform]
txnDirectionColumn=txn_direction_desc
debitColumn=ACCOUNT_ID
creditColumn=COUNTERPARTY_ID

[b_account_id_transform]
txnDirectionColumn=txn_direction_desc
debitColumn=COUNTERPARTY_ID
creditColumn=ACCOUNT_ID

[transaction_class]
column=transactionClass

Summary

With these additions:
	•	validateAAccountId and validateBAccountId will apply transformations based on txn_direction_desc and identify mismatches.
	•	validateTransactionClass will check for distinct values in transactionClass.
	•	The configuration makes these validations flexible and adaptable.

Let me know if you have additional requirements!