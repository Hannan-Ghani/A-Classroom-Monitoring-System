// Import necessary libraries
import org.apache.spark.sql.functions._
import org.apache.spark.sql.types._
import org.apache.spark.sql.{SparkSession, SQLContext}

// Initialize Spark session (in AWS Glue, GlueContext typically manages this)
val spark = SparkSession.builder.appName("GlueETLJob").getOrCreate()
import spark.implicits._

// Read and filter customer data
val a_cus = spark.read.parquet("s3://136731789529-fis-raw-data/customer/20230309/raw/parquet/")
  .filter("NUM_OF_ACCOUNT >= 0 and (SOURCE_COUNTRY <> 'ZA' or SOURCE_COUNTRY is NULL) and customer_key is not NULL and customer_key not in ('TMAMLO-T', 'TMEMA-*', 'TMUK1-*', 'TMUK2*', 'Not Available')")
  .withColumn("customerUniqueId", regexp_replace(col("customer_key"), "[^A-Za-z0-9]", ""))
a_cus.createOrReplaceTempView("a_cus")
a_cus.cache()

// Read and filter product data
val a_prod = spark.read.parquet("s3://136731789529-fis-raw-data/product/20230203/raw/parquet/")
  .filter((col("account_key").isNotNull || col("customer_key").isNotNull) && 
          (when(col("screening_system").isin("UKCMLPVHI", "UKCMLPV100", "UKCMLPVSK", "UKCMLPV500", "UKCMLPV10K", "UKCMLPVIK", "UKCMLPUNK", "UMLPBHI", "UKC P8200", "КСМІРВК", "КСМРВ5О", "иКСМІРЕК", "ИКСРВК"), lit(true)).otherwise(lit(false))))
a_prod.createOrReplaceTempView("a_prod")
a_prod.cache()

// Join customer and product data
val prod_qtx = a_cus.join(a_prod, a_cus("customerUniqueId") === a_prod("customerUniqueId"), "inner")
prod_qtx.createOrReplaceTempView("prod_qtx")
prod_qtx.cache()

// Define source fields with necessary transformations
val src_fields = spark.sql("""
  SELECT customerUniqueId, account_risk_code_desc, name as accountName, substring(account_id,0,5) as accountIdPrefix, 
  account_no as accountNumber, account_no as CleansedAccountNumber, account_key as accountKey, company_id as companyId, 
  country_code as country, currency_code as currencyCode, 
  CASE WHEN financial_institution = 'N' THEN 'false' ELSE 'true' END as financialInstitution,
  update_tms as lastUpdatedDate, line_of_business_desc as lineOfBusiness, 
  CASE WHEN joint_account = 'N' THEN 'false' ELSE 'true' END as jointAccount, 
  CASE WHEN non_operating_entity = 'N' THEN 'false' ELSE 'true' END as nonOperatingEntity, 
  CASE WHEN numbered_account = 'N' THEN 'false' ELSE 'true' END as numberedAccount, 
  product_id as productId, region_id as regionId, risk_code as riskCode, 
  relman_id as rmId, relman_name as rmName, 
  CASE WHEN sensitive_industry = 'N' THEN 'false' ELSE 'true' END as sensitiveIndustry, 
  sortcode as sortcode, sortcode as cleansedSortCode, source_sys_code as sourceSystem, 
  high_account_type as highAccountType, high_account_type_desc as highAccountTypeDescription, 
  low_account_type as lowAccountType, low_account_type_desc as lowAccountTypeDescription, 
  external_account_type as externalAccountType, industry_code_desc as industryCodeDescription 
  FROM prod_qtx
""")
src_fields.createOrReplaceTempView("src_fields")
src_fields.cache()

// Load target data and explode account details
val Qxta_targt = spark.read.parquet("s3://136731789529-fis-interim-data/customer/2023-05-19_14-31-53-631/DocumentDataModel/DocumentDataModel.parquet/")
  .select($"customerUniqueId", explode($"account").alias("account"))
  .select("customerUniqueId", "account.*")
Qxta_targt.createOrReplaceTempView("Qxta_targt")
Qxta_targt.cache()

// Select required fields from the target data
val selected_Qxta_targt = spark.sql("""
  SELECT customerUniqueId, accountRiskCodeDescription, accountName, accountIdPrefix, accountNumber, cleansedAccountNumber, accountKey, 
  companyId, country, currencyCode, cast(financialInstitution as string) as financialInstitution, 
  cast(jointAccount as String) as jointAccount, lastUpdatedDate, lineOfBusiness, lineOfBusinessDescription, 
  maturityDate, cast(nonOperatingEntity as string) as nonOperatingEntity, cast(numberedAccount as string) as numberedAccount, 
  productId, regionId, riskCode, rmId, rmName, cast(sensitiveIndustry as string) as sensitiveIndustry, 
  sortcode, cleansedSortCode, sourceSystem, highAccountType, highAccountTypeDescription, 
  lowAccountType, lowAccountTypeDescription, externalAccountType, industryCodeDescription 
  FROM Qxta_targt
""")
selected_Qxta_targt.createOrReplaceTempView("selected_Qxta_targt")
selected_Qxta_targt.cache()
