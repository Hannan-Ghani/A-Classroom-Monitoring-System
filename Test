To implement this validation, where aAccountId and bAccountId are transformed into aSortCode and bSortCode based on specific conditions, we’ll follow the same approach as before:
	1.	Add configuration sections to specify the prefixes and substring rules.
	2.	Define parsing logic to handle these configurations.
	3.	Create two validation functions for aSortCode and bSortCode.

Step 1: Add Configuration Support

Add configuration sections for aSortCode and bSortCode transformations. These sections should specify:
	•	The transaction direction condition (DEBIT for aSortCode, CREDIT for bSortCode).
	•	Prefixes for the account IDs.
	•	The substring positions.

Example configuration:

[a_sort_code_transform]
txnDirectionCondition=DEBIT
prefixes=UKUBA,UKGTS
substringStart=17
substringLength=6

[b_sort_code_transform]
txnDirectionCondition=CREDIT
prefixes=UKUBA,UKGTS
substringStart=17
substringLength=6

This configuration will:
	•	Define the conditions for when to apply the substring transformation.
	•	Specify the prefixes and substring parameters.

Step 2: Add Parsing Logic to parseValidationConfig

Add cases in parseValidationConfig to handle a_sort_code_transform and b_sort_code_transform sections:

case "a_sort_code_transform" =>
  val txnDirectionCondition = configMap("txnDirectionCondition").trim
  val prefixes = configMap("prefixes").split(",").map(_.trim)
  val substringStart = configMap("substringStart").toInt
  val substringLength = configMap("substringLength").toInt
  validationConfig += ("aSortCodeDirectionCondition" -> txnDirectionCondition)
  validationConfig += ("aSortCodePrefixes" -> prefixes)
  validationConfig += ("aSortCodeSubstringStart" -> substringStart)
  validationConfig += ("aSortCodeSubstringLength" -> substringLength)

case "b_sort_code_transform" =>
  val txnDirectionCondition = configMap("txnDirectionCondition").trim
  val prefixes = configMap("prefixes").split(",").map(_.trim)
  val substringStart = configMap("substringStart").toInt
  val substringLength = configMap("substringLength").toInt
  validationConfig += ("bSortCodeDirectionCondition" -> txnDirectionCondition)
  validationConfig += ("bSortCodePrefixes" -> prefixes)
  validationConfig += ("bSortCodeSubstringStart" -> substringStart)
  validationConfig += ("bSortCodeSubstringLength" -> substringLength)

This parsing logic stores:
	•	The direction condition, prefixes, and substring parameters for each transformation.

Step 3: Define Validation Functions

validateASortCode

This function applies the transformation for aSortCode based on the aAccountId condition:

def validateASortCode(sourceDF: DataFrame, targetDF: DataFrame, configMap: Map[String, Any]): Seq[String] = {
  import sourceDF.sparkSession.implicits._

  // Retrieve settings from config
  val directionCondition = configMap("aSortCodeDirectionCondition").toString
  val prefixes = configMap("aSortCodePrefixes").asInstanceOf[Array[String]]
  val substringStart = configMap("aSortCodeSubstringStart").asInstanceOf[Int]
  val substringLength = configMap("aSortCodeSubstringLength").asInstanceOf[Int]

  // Apply the conditional transformation for `aSortCode`
  val source = sourceDF.withColumn("aSortCode",
    when($"txn_direction_desc" === directionCondition && substring($"aAccountId", 1, 5).isin(prefixes: _*), 
         substring($"aAccountId", substringStart, substringLength))
      .otherwise(null)
  ).select($"transaction_id".as("transactionId"), $"aSortCode")

  val target = targetDF.select($"transactionId", $"aSortCode")

  val sourceToTargetDiff = source.exceptAll(target)
  val targetToSourceDiff = target.exceptAll(source)

  val sourceToTargetIds = sourceToTargetDiff.select($"transactionId").as[String].collect()
  val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

  Seq(
    "A Sort Code Validation Differences:",
    s"Source to Target Differences: ${sourceToTargetIds.length} found with transaction IDs: ${sourceToTargetIds.mkString(", ")}",
    s"Target to Source Differences: ${targetToSourceIds.length} found with transaction IDs: ${targetToSourceIds.mkString(", ")}"
  )
}

validateBSortCode

Similarly, define a function for bSortCode transformation:

def validateBSortCode(sourceDF: DataFrame, targetDF: DataFrame, configMap: Map[String, Any]): Seq[String] = {
  import sourceDF.sparkSession.implicits._

  val directionCondition = configMap("bSortCodeDirectionCondition").toString
  val prefixes = configMap("bSortCodePrefixes").asInstanceOf[Array[String]]
  val substringStart = configMap("bSortCodeSubstringStart").asInstanceOf[Int]
  val substringLength = configMap("bSortCodeSubstringLength").asInstanceOf[Int]

  val source = sourceDF.withColumn("bSortCode",
    when($"txn_direction_desc" === directionCondition && substring($"bAccountId", 1, 5).isin(prefixes: _*), 
         substring($"bAccountId", substringStart, substringLength))
      .otherwise(null)
  ).select($"transaction_id".as("transactionId"), $"bSortCode")

  val target = targetDF.select($"transactionId", $"bSortCode")

  val sourceToTargetDiff = source.exceptAll(target)
  val targetToSourceDiff = target.exceptAll(source)

  val sourceToTargetIds = sourceToTargetDiff.select($"transactionId").as[String].collect()
  val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

  Seq(
    "B Sort Code Validation Differences:",
    s"Source to Target Differences: ${sourceToTargetIds.length} found with transaction IDs: ${sourceToTargetIds.mkString(", ")}",
    s"Target to Source Differences: ${targetToSourceIds.length} found with transaction IDs: ${targetToSourceIds.mkString(", ")}"
  )
}

Step 4: Integrate the Functions into the Main Flow

In your main method, after parsing the configuration, call each validation function:

validationResults = validationResults ++ validateASortCode(transactionSource, caseClass, validationConfigMap)
validationResults = validationResults ++ validateBSortCode(transactionSource, caseClass, validationConfigMap)

Example Configuration File

Here’s the complete configuration with sections for aSortCode and bSortCode:

[a_sort_code_transform]
txnDirectionCondition=DEBIT
prefixes=UKUBA,UKGTS
substringStart=17
substringLength=6

[b_sort_code_transform]
txnDirectionCondition=CREDIT
prefixes=UKUBA,UKGTS
substringStart=17
substringLength=6

Summary

With these additions:
	•	validateASortCode and validateBSortCode functions apply substring transformations based on the specified conditions.
	•	Mismatches between source and target are identified and reported.
	•	Configuration allows flexibility in defining prefixes, conditions, and substring parameters.

Let me know if further customization is needed!