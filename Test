This code involves two distinct transformations:
	1.	Creating bCustomerId based on txn_direction_desc and selecting either COUNTERPARTY_CUSTOMER_KEY or CUSTOMER_KEY.
	2.	Creating aCustomerId based on txn_direction_desc and selecting either CUSTOMER_KEY or COUNTERPARTY_CUSTOMER_KEY.

Each transformation will need its own validation function, configuration sections, and parsing logic.

Step 1: Add Configuration Support

Add configuration sections for both bCustomerId and aCustomerId transformations. Each configuration section should specify:
	•	The column for transaction direction (txn_direction_desc).
	•	The columns to use based on the transaction direction (CUSTOMER_KEY and COUNTERPARTY_CUSTOMER_KEY).

Example configuration:

[b_customer_id_transform]
txnDirectionColumn=txn_direction_desc
debitColumn=COUNTERPARTY_CUSTOMER_KEY
creditColumn=CUSTOMER_KEY

[a_customer_id_transform]
txnDirectionColumn=txn_direction_desc
debitColumn=CUSTOMER_KEY
creditColumn=COUNTERPARTY_CUSTOMER_KEY

This configuration allows each transformation to use the specified direction and customer columns for creating bCustomerId and aCustomerId.

Step 2: Add Parsing Logic to parseValidationConfig

Add cases in parseValidationConfig to parse the b_customer_id_transform and a_customer_id_transform sections:

case "b_customer_id_transform" =>
  val columns = trimmedLine.split(",").map(_.trim)
  if (columns.length == 3) {
    validationConfig += ("txnDirectionColumnForB" -> columns(0))
    validationConfig += ("debitColumnForBCustomerId" -> columns(1))
    validationConfig += ("creditColumnForBCustomerId" -> columns(2))
  } else {
    println(s"Warning: Invalid format for bCustomerId transform - $trimmedLine")
  }

case "a_customer_id_transform" =>
  val columns = trimmedLine.split(",").map(_.trim)
  if (columns.length == 3) {
    validationConfig += ("txnDirectionColumnForA" -> columns(0))
    validationConfig += ("debitColumnForACustomerId" -> columns(1))
    validationConfig += ("creditColumnForACustomerId" -> columns(2))
  } else {
    println(s"Warning: Invalid format for aCustomerId transform - $trimmedLine")
  }

This parsing logic will store the necessary columns for each transformation in validationConfig:
	•	For bCustomerId, it will use txnDirectionColumnForB, debitColumnForBCustomerId, and creditColumnForBCustomerId.
	•	For aCustomerId, it will use txnDirectionColumnForA, debitColumnForACustomerId, and creditColumnForACustomerId.

Step 3: Define Validation Functions

validateBCustomerId

This function will:
	•	Retrieve the relevant columns from configMap.
	•	Conditionally assign bCustomerId based on txn_direction_desc.
	•	Use exceptAll to find mismatches with caseClass.

def validateBCustomerId(sourceDF: DataFrame, targetDF: DataFrame, configMap: Map[String, Any]): Seq[String] = {
  import sourceDF.sparkSession.implicits._

  val txnDirectionColumn = configMap.getOrElse("txnDirectionColumnForB", "txn_direction_desc").toString
  val debitColumn = configMap.getOrElse("debitColumnForBCustomerId", "COUNTERPARTY_CUSTOMER_KEY").toString
  val creditColumn = configMap.getOrElse("creditColumnForBCustomerId", "CUSTOMER_KEY").toString

  // Apply conditional logic to create `bCustomerId`
  val source = sourceDF.withColumn("bCustomerId",
    when(col(txnDirectionColumn) === "DEBIT", col(debitColumn))
      .when(col(txnDirectionColumn) === "CREDIT", col(creditColumn))
      .otherwise(null)
  ).filter(col(txnDirectionColumn).isin("DEBIT", "CREDIT"))
   .select($"transaction_id".as("transactionId"), $"bCustomerId")

  val target = targetDF.select($"transactionId", $"bCustomerId")

  val sourceToTargetDiff = source.exceptAll(target)
  val targetToSourceDiff = target.exceptAll(source)

  val sourceToTargetIds = sourceToTargetDiff.select($"transactionId").as[String].collect()
  val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

  Seq(
    "B Customer ID Validation Differences:",
    s"Source to Target Differences: ${sourceToTargetIds.length} found with transaction IDs: ${sourceToTargetIds.mkString(", ")}",
    s"Target to Source Differences: ${targetToSourceIds.length} found with transaction IDs: ${targetToSourceIds.mkString(", ")}"
  )
}

validateACustomerId

This function is similar but uses different columns from the config.

def validateACustomerId(sourceDF: DataFrame, targetDF: DataFrame, configMap: Map[String, Any]): Seq[String] = {
  import sourceDF.sparkSession.implicits._

  val txnDirectionColumn = configMap.getOrElse("txnDirectionColumnForA", "txn_direction_desc").toString
  val debitColumn = configMap.getOrElse("debitColumnForACustomerId", "CUSTOMER_KEY").toString
  val creditColumn = configMap.getOrElse("creditColumnForACustomerId", "COUNTERPARTY_CUSTOMER_KEY").toString

  // Apply conditional logic to create `aCustomerId`
  val source = sourceDF.withColumn("aCustomerId",
    when(col(txnDirectionColumn) === "DEBIT", col(debitColumn))
      .when(col(txnDirectionColumn) === "CREDIT", col(creditColumn))
      .otherwise(null)
  ).select($"transaction_id".as("transactionId"), $"aCustomerId")

  val target = targetDF.select($"transactionId", $"aCustomerId")

  val sourceToTargetDiff = source.exceptAll(target)
  val targetToSourceDiff = target.exceptAll(source)

  val sourceToTargetIds = sourceToTargetDiff.select($"transactionId").as[String].collect()
  val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

  Seq(
    "A Customer ID Validation Differences:",
    s"Source to Target Differences: ${sourceToTargetIds.length} found with transaction IDs: ${sourceToTargetIds.mkString(", ")}",
    s"Target to Source Differences: ${targetToSourceIds.length} found with transaction IDs: ${targetToSourceIds.mkString(", ")}"
  )
}

Step 4: Integrate Functions into Main Flow

In your main method, call each validation function after parsing the configuration:

validationResults = validationResults ++ validateBCustomerId(transactionSource, caseClass, validationConfigMap)
validationResults = validationResults ++ validateACustomerId(transactionSource, caseClass, validationConfigMap)

Complete Configuration Example

Here’s the complete configuration file with sections for both bCustomerId and aCustomerId transformations:

[b_customer_id_transform]
txnDirectionColumn=txn_direction_desc
debitColumn=COUNTERPARTY_CUSTOMER_KEY
creditColumn=CUSTOMER_KEY

[a_customer_id_transform]
txnDirectionColumn=txn_direction_desc
debitColumn=CUSTOMER_KEY
creditColumn=COUNTERPARTY_CUSTOMER_KEY

Summary

With this setup, the code will:
	1.	Parse the necessary columns for bCustomerId and aCustomerId from the configuration.
	2.	Apply conditional transformations based on txn_direction_desc.
	3.	Compare results with exceptAll and output mismatched transaction IDs.

Let me know if you need further customization!