The TypeMismatch error here is because validateTransformedAccountNumbers expects configMap to be of type Map[String, Seq[String]], but validationConfigMap is actually of type Map[String, Any]. This mismatch happens when getOrElse returns Any instead of Seq[String], similar to the issue we addressed before.

Solution: Filter and Cast Configuration for validateTransformedAccountNumbers

To fix this, we need to:
	1.	Extract the specific configuration key from validationConfigMap.
	2.	Ensure it is cast to Seq[String] before passing it to validateTransformedAccountNumbers.

Here’s how you can do it:
	1.	Extract and Cast Configuration: Before calling validateTransformedAccountNumbers, retrieve the specific key from validationConfigMap, cast it to Seq[String], and pass it as the second argument.
	2.	Handle Each Key Separately: Since you’re calling validateTransformedAccountNumbers with different keys, apply this approach for each key separately.

Revised Code Example

Here’s how you can modify the code:

// Extract and cast the configuration for each validation call
val firstAccountConfig = validationConfigMap.getOrElse("account number transform", Seq.empty[String]).asInstanceOf[Seq[String]]
val secondAccountConfig = validationConfigMap.getOrElse("second account number transform", Seq.empty[String]).asInstanceOf[Seq[String]]

// Call validateTransformedAccountNumbers with the extracted configurations
validationResults = validationResults ++ validateTransformedAccountNumbers(caseClass, Map("account number transform" -> firstAccountConfig), "account number transform")
validationResults = validationResults ++ validateTransformedAccountNumbers(caseClass, Map("second account number transform" -> secondAccountConfig), "second account number transform")

Explanation

	•	Extract and Cast: We retrieve account number transform and second account number transform configurations from validationConfigMap. If these keys are missing, we provide an empty Seq[String].
	•	Convert Each Key to Map[String, Seq[String]]: Since validateTransformedAccountNumbers expects a Map[String, Seq[String]], we wrap each configuration in its own Map.
	•	Pass Correctly Typed Configuration: Each call to validateTransformedAccountNumbers now receives a correctly typed configuration map with only the specific key it needs.

Updated validateTransformedAccountNumbers Function Call

Now, each call to validateTransformedAccountNumbers should look like this:

validationResults = validationResults ++ validateTransformedAccountNumbers(caseClass, Map("account number transform" -> firstAccountConfig), "account number transform")
validationResults = validationResults ++ validateTransformedAccountNumbers(caseClass, Map("second account number transform" -> secondAccountConfig), "second account number transform")

This approach ensures that validateTransformedAccountNumbers receives the correct type (Map[String, Seq[String]]), resolving the TypeMismatch error.

Additional Note

If you have many such keys, consider creating a helper function that does this extraction and casting for you to avoid repetition:

def getConfigAsSeq(configMap: Map[String, Any], key: String): Seq[String] = {
  configMap.getOrElse(key, Seq.empty[String]).asInstanceOf[Seq[String]]
}

// Use the helper function
validationResults = validationResults ++ validateTransformedAccountNumbers(caseClass, Map("account number transform" -> getConfigAsSeq(validationConfigMap, "account number transform")), "account number transform")
validationResults = validationResults ++ validateTransformedAccountNumbers(caseClass, Map("second account number transform" -> getConfigAsSeq(validationConfigMap, "second account number transform")), "second account number transform")

Let me know if this resolves the issue or if you encounter further challenges!