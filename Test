To implement this validation, which involves determining aAccountType and bAccountType based on the values of aAccountId and bAccountId, we’ll need:
	1.	A configuration file to specify the list of identifiers for each account type (e.g., “BANK ACCOUNT,” “CREDIT CARD,” “MORTGAGE”).
	2.	Parsing logic to handle these identifiers.
	3.	A function to apply the conditional transformation for both aAccountType and bAccountType.

Here’s how we’ll set it up.

Step 1: Add Configuration Support

Add configuration sections for aAccountType and bAccountType transformations. Each section will include the identifiers for each type:

[a_account_type_transform]
bankAccountPrefixes=HK100,HK102,HK103,HK400,HK404,HKG00,KEFIX,KEPRM,MUBRN,MUPRM,OBBRN,SCBRN,SCVSP,SH403,SH404,SHG00,UGFLX,UGVSP,UKUBA,ZACAR,ZACHE,ZACTS,ZALOA,ZAMID,ZAMLO,ZANED,ZASAV,ZATDE,UKGTS
creditCardPrefixes=UKPRM,UKPSP,UKTPE,UKBNC,UKBNW,UKBPA,UKBPF,UKCAM,UKCML,PTPSP,ITPSP,ESPSP
mortgagePrefixes=UKTRN
defaultType=BANK ACCOUNT

[b_account_type_transform]
bankAccountPrefixes=HK100,HK102,HK103,HK400,HK404,HKG00,KEFIX,KEPRM,MUBRN,MUPRM,OBBRN,SCBRN,SCVSP,SH403,SH404,SHG00,UGFLX,UGVSP,UKUBA,ZACAR,ZACHE,ZACTS,ZALOA,ZAMID,ZAMLO,ZANED,ZASAV,ZATDE,UKGTS
creditCardPrefixes=UKPRM,UKPSP,UKTPE,UKBNC,UKBNW,UKBPA,UKBPF,UKCAM,UKCML,PTPSP,ITPSP,ESPSP
mortgagePrefixes=UKTRN
defaultType=BANK ACCOUNT

This configuration will allow us to:
	•	Specify prefixes for each account type category.
	•	Provide a default account type (BANK ACCOUNT) if no other type matches.

Step 2: Add Parsing Logic to parseValidationConfig

Update parseValidationConfig to parse these new sections:

case "a_account_type_transform" =>
  val bankAccountPrefixes = configMap("bankAccountPrefixes").split(",").map(_.trim)
  val creditCardPrefixes = configMap("creditCardPrefixes").split(",").map(_.trim)
  val mortgagePrefixes = configMap("mortgagePrefixes").split(",").map(_.trim)
  val defaultType = configMap("defaultType").trim
  validationConfig += ("aAccountBankPrefixes" -> bankAccountPrefixes)
  validationConfig += ("aAccountCreditPrefixes" -> creditCardPrefixes)
  validationConfig += ("aAccountMortgagePrefixes" -> mortgagePrefixes)
  validationConfig += ("aAccountDefaultType" -> defaultType)

case "b_account_type_transform" =>
  val bankAccountPrefixes = configMap("bankAccountPrefixes").split(",").map(_.trim)
  val creditCardPrefixes = configMap("creditCardPrefixes").split(",").map(_.trim)
  val mortgagePrefixes = configMap("mortgagePrefixes").split(",").map(_.trim)
  val defaultType = configMap("defaultType").trim
  validationConfig += ("bAccountBankPrefixes" -> bankAccountPrefixes)
  validationConfig += ("bAccountCreditPrefixes" -> creditCardPrefixes)
  validationConfig += ("bAccountMortgagePrefixes" -> mortgagePrefixes)
  validationConfig += ("bAccountDefaultType" -> defaultType)

This code will parse:
	•	aAccountBankPrefixes, aAccountCreditPrefixes, and aAccountMortgagePrefixes for aAccountType.
	•	bAccountBankPrefixes, bAccountCreditPrefixes, and bAccountMortgagePrefixes for bAccountType.

Step 3: Define the Validation Functions

validateAAccountType

This function applies the transformation for aAccountType based on aAccountId:

def validateAAccountType(sourceDF: DataFrame, targetDF: DataFrame, configMap: Map[String, Any]): Seq[String] = {
  import sourceDF.sparkSession.implicits._

  // Retrieve prefixes and default type from config
  val bankPrefixes = configMap("aAccountBankPrefixes").asInstanceOf[Array[String]]
  val creditCardPrefixes = configMap("aAccountCreditPrefixes").asInstanceOf[Array[String]]
  val mortgagePrefixes = configMap("aAccountMortgagePrefixes").asInstanceOf[Array[String]]
  val defaultType = configMap("aAccountDefaultType").toString

  // Define a conditional transformation for `aAccountType`
  val source = sourceDF.withColumn("aAccountType",
    when(substring($"aAccountId", 1, 5).isin(bankPrefixes: _*) && $"aAccountId".isNotNull, "BANK ACCOUNT")
      .when(substring($"aAccountId", 1, 5).isin(creditCardPrefixes: _*) && $"aAccountId".isNotNull, "CREDIT CARD")
      .when(substring($"aAccountId", 1, 5).isin(mortgagePrefixes: _*) && $"aAccountId".isNotNull, "MORTGAGE")
      .otherwise(when($"aAccountId".isNotNull, defaultType).otherwise(null))
  ).select($"transaction_id".as("transactionId"), $"aAccountType")

  val target = targetDF.select($"transactionId", $"aAccountType")

  val sourceToTargetDiff = source.exceptAll(target)
  val targetToSourceDiff = target.exceptAll(source)

  val sourceToTargetIds = sourceToTargetDiff.select($"transactionId").as[String].collect()
  val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

  Seq(
    "A Account Type Validation Differences:",
    s"Source to Target Differences: ${sourceToTargetIds.length} found with transaction IDs: ${sourceToTargetIds.mkString(", ")}",
    s"Target to Source Differences: ${targetToSourceIds.length} found with transaction IDs: ${targetToSourceIds.mkString(", ")}"
  )
}

validateBAccountType

Similarly, define a function for bAccountType transformation:

def validateBAccountType(sourceDF: DataFrame, targetDF: DataFrame, configMap: Map[String, Any]): Seq[String] = {
  import sourceDF.sparkSession.implicits._

  val bankPrefixes = configMap("bAccountBankPrefixes").asInstanceOf[Array[String]]
  val creditCardPrefixes = configMap("bAccountCreditPrefixes").asInstanceOf[Array[String]]
  val mortgagePrefixes = configMap("bAccountMortgagePrefixes").asInstanceOf[Array[String]]
  val defaultType = configMap("bAccountDefaultType").toString

  val source = sourceDF.withColumn("bAccountType",
    when(substring($"bAccountId", 1, 5).isin(bankPrefixes: _*) && $"bAccountId".isNotNull, "BANK ACCOUNT")
      .when(substring($"bAccountId", 1, 5).isin(creditCardPrefixes: _*) && $"bAccountId".isNotNull, "CREDIT CARD")
      .when(substring($"bAccountId", 1, 5).isin(mortgagePrefixes: _*) && $"bAccountId".isNotNull, "MORTGAGE")
      .otherwise(when($"bAccountId".isNotNull, defaultType).otherwise(null))
  ).select($"transaction_id".as("transactionId"), $"bAccountType")

  val target = targetDF.select($"transactionId", $"bAccountType")

  val sourceToTargetDiff = source.exceptAll(target)
  val targetToSourceDiff = target.exceptAll(source)

  val sourceToTargetIds = sourceToTargetDiff.select($"transactionId").as[String].collect()
  val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

  Seq(
    "B Account Type Validation Differences:",
    s"Source to Target Differences: ${sourceToTargetIds.length} found with transaction IDs: ${sourceToTargetIds.mkString(", ")}",
    s"Target to Source Differences: ${targetToSourceIds.length} found with transaction IDs: ${targetToSourceIds.mkString(", ")}"
  )
}

Step 4: Integrate Functions into Main Flow

In your main method, call each validation function after parsing the configuration:

validationResults = validationResults ++ validateAAccountType(transactionSource, caseClass, validationConfigMap)
validationResults = validationResults ++ validateBAccountType(transactionSource, caseClass, validationConfigMap)

Example Configuration File

Here’s the complete configuration with sections for aAccountType and bAccountType:

[a_account_type_transform]
bankAccountPrefixes=HK100,HK102,HK103,HK400,HK404,HKG00,KEFIX,KEPRM,MUBRN,MUPRM,OBBRN,SCBRN,SCVSP,SH403,SH404,SHG00,UGFLX,UGVSP,UKUBA,ZACAR,ZACHE,ZACTS,ZALOA,ZAMID,ZAMLO,ZANED