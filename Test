import com.amazonaws.services.glue.GlueContext
import com.amazonaws.services.glue.util.Job
import org.apache.spark.SparkContext
import org.apache.spark.sql.{DataFrame, SparkSession}
import org.apache.spark.sql.functions._
import org.apache.log4j.Logger
import com.amazonaws.services.glue.util.GlueArgParser
import java.io.PrintWriter

object CleanseCaseClass {

  def main(sysArgs: Array[String]): Unit = {
    val spark: SparkContext = new SparkContext()
    val glueContext: GlueContext = new GlueContext(spark)
    val sparkSession: SparkSession = glueContext.getSparkSession
    import sparkSession.implicits._

    val logger: Logger = Logger.getLogger("CleanseCaseClassLogger")

    // Get Glue job parameters for config paths
    val args = GlueArgParser.getResolvedOptions(sysArgs, Seq("s3PathConfig", "s3ValidationConfig").toArray)
    val s3PathConfig = args("s3PathConfig")
    val s3ValidationConfig = args("s3ValidationConfig")

    // Read the path configuration file from S3
    val pathConfigDF = sparkSession.read.text(s3PathConfig)
    val pathConfigMap = pathConfigDF.collect().map { row =>
      val split = row.getString(0).split("=")
      (split(0), split(1))
    }.toMap

    // Extract paths from the path config
    val inputSourcePath = pathConfigMap("inputSourcePath")
    val inputTargetPath = pathConfigMap("inputTargetPath")
    val outputBasePath = pathConfigMap("outputBasePath")

    // Load source and target data
    val transactionSource: DataFrame = sparkSession.read.parquet(inputSourcePath)
    val caseClass: DataFrame = sparkSession.read.parquet(inputTargetPath)

    // Read validation configuration file from S3
    val validationConfigDF = sparkSession.read.text(s3ValidationConfig)
    val validationConfigMap = parseValidationConfig(validationConfigDF)

    // Initialize output file
    val outputFile = s"$outputBasePath/validation_differences.txt"
    val writer = new PrintWriter(outputFile)

    // Helper Functions
    def filterExistingColumns(df: DataFrame, columns: Seq[String]): Seq[String] = {
      val existingColumns = df.columns.toSet
      val validColumns = columns.filter(existingColumns.contains)
      if (validColumns.size < columns.size) {
        val missingColumns = columns.diff(validColumns)
        logger.warn(s"Missing columns: ${missingColumns.mkString(", ")}")
      }
      validColumns
    }

    def filterExistingColumnPairs(sourceColumns: Seq[String], targetColumns: Seq[String], sourceDF: DataFrame, targetDF: DataFrame): (Seq[String], Seq[String]) = {
      val existingSourceColumns = sourceDF.columns.toSet
      val existingTargetColumns = targetDF.columns.toSet
      val filteredSourceColumns = sourceColumns.zip(targetColumns).collect {
        case (sourceCol, targetCol) if existingSourceColumns.contains(sourceCol) && existingTargetColumns.contains(targetCol) =>
          sourceCol
      }
      val filteredTargetColumns = sourceColumns.zip(targetColumns).collect {
        case (sourceCol, targetCol) if existingSourceColumns.contains(sourceCol) && existingTargetColumns.contains(targetCol) =>
          targetCol
      }
      (filteredSourceColumns, filteredTargetColumns)
    }

    // =======================
    // Null Validation
    // =======================
    val nullColumns = validationConfigMap.getOrElse("null_validation", Seq())
    val existingNullColumns = filterExistingColumns(caseClass, nullColumns)

    if (existingNullColumns.nonEmpty) {
      val nonNullData = caseClass.filter(existingNullColumns.map(col => col(col).isNotNull).reduce(_ || _))
      val nonNullTransactionIds = nonNullData.select("transactionid").as[String].collect()
      writer.write("Null Validation Differences:\n")
      writer.write("Non-null values found for columns expected to be null in rows: " + nonNullTransactionIds.mkString(", ") + "\n\n")
    } else {
      writer.write("Null Validation Differences: No relevant columns found for null validation.\n\n")
    }

    // =======================
    // Direct Column Validation
    // =======================
    val sourceCols = validationConfigMap.getOrElse("direct_column_validation_source", Seq())
    val targetCols = validationConfigMap.getOrElse("direct_column_validation_target", Seq())

    val (alignedSourceCols, alignedTargetCols) = filterExistingColumnPairs(sourceCols, targetCols, transactionSource, caseClass)

    if (alignedSourceCols.nonEmpty && alignedTargetCols.nonEmpty) {
      val sourceData = transactionSource.select(alignedSourceCols.zipWithIndex.map { case (col, i) => col(col).as(s"col_$i") }: _*)
      val targetData = caseClass.select(alignedTargetCols.zipWithIndex.map { case (col, i) => col(col).as(s"col_$i") }: _*)

      val sourceToTargetDiff = sourceData.except(targetData)
      val targetToSourceDiff = targetData.except(sourceData)

      val sourceToTargetIds = sourceToTargetDiff.select("col_0").as[String].collect()
      val targetToSourceIds = targetToSourceDiff.select("col_0").as[String].collect()

      writer.write("Direct Column Validation Differences:\n")
      writer.write("Source to Target Differences: " + sourceToTargetIds.mkString(", ") + "\n")
      writer.write("Target to Source Differences: " + targetToSourceIds.mkString(", ") + "\n\n")
    } else {
      writer.write("Direct Column Validation Differences: No relevant columns found for direct validation.\n\n")
    }

    // =======================
    // Narrative Validation
    // =======================
    val sourceNarrativeCol = validationConfigMap.getOrElse("narrative_validation_source", Seq()).headOption.getOrElse("")
    val targetNarrativeCol = validationConfigMap.getOrElse("narrative_validation_target", Seq()).headOption.getOrElse("")

    val cleanedSourceNarrative = transactionSource.withColumn("cleaned_narrative", 
      when(trim(col(sourceNarrativeCol)) === "" || trim(col(sourceNarrativeCol)) === "*", null)
        .otherwise(col(sourceNarrativeCol))
    ).select($"TRANSACTION_ID", $"cleaned_narrative")

    val targetNarrative = caseClass.select($"transactionid", col(targetNarrativeCol).as("cleaned_narrative"))

    val narrativeSourceToTargetDiff = cleanedSourceNarrative.except(targetNarrative)
    val narrativeTargetToSourceDiff = targetNarrative.except(cleanedSourceNarrative)

    val narrativeSourceToTargetIds = narrativeSourceToTargetDiff.select("TRANSACTION_ID").as[String].collect()
    val narrativeTargetToSourceIds = narrativeTargetToSourceDiff.select("transactionid").as[String].collect()

    writer.write("Narrative Validation Differences:\n")
    writer.write("Source to Target Differences: " + narrativeSourceToTargetIds.mkString(", ") + "\n")
    writer.write("Target to Source Differences: " + narrativeTargetToSourceIds.mkString(", ") + "\n\n")

    // Close the writer and finalize the job
    writer.close()
    Job.commit()
  }

  // Helper function to parse validation configuration into a map
  def parseValidationConfig(configDF: DataFrame): Map[String, Seq[String]] = {
    var currentSection = ""
    var validationConfig = Map[String, Seq[String]]()

    configDF.collect().foreach { row =>
      val line = row.getString(0).trim
      if (line.startsWith("[") && line.endsWith("]")) {
        currentSection = line.substring(1, line.length - 1)
        validationConfig += (currentSection -> Seq())
      } else if (line.nonEmpty && currentSection.nonEmpty) {
        val columns = line.split(",").map(_.trim).toSeq
        validationConfig += (currentSection -> columns)
      }
    }
    validationConfig
  }
}