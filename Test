The code you posted appears to be almost identical to the previous example you shared for generating bAccountUniqueId based on the values of COUNTERPARTY_PRODUCT_KEY and ACCOUNT_KEY. However, since you’ve asked to “do the same,” I’ll provide a structured approach just in case there’s a subtle variation in the requirements that may require a new setup or if this is intended as a similar yet distinct validation.

Here’s a structured approach to replicate this validation in your codebase.

1. Add Configuration Support

If this validation differs from the previous bAccountUniqueId logic (perhaps due to different columns or conditions), specify the unique configurations in a new section. Here’s an example:

[unique_b_account_id_2_join_columns]
transactionSourceId=transaction_id
caseClassId=transactionId

[unique_b_account_id_2_transform]
txnDirectionColumn=txn_direction_desc
debitColumn=COUNTERPARTY_PRODUCT_KEY
creditColumn=ACCOUNT_KEY

This configuration will:
	•	Use unique_b_account_id_2_join_columns for join columns (transactionSourceId and caseClassId).
	•	Use unique_b_account_id_2_transform for transformation columns and conditions, where:
	•	txnDirectionColumn indicates the transaction direction column.
	•	debitColumn indicates the column to use if the transaction direction is “DEBIT.”
	•	creditColumn indicates the column to use otherwise.

2. Add Parsing Logic to parseValidationConfig

Add cases to parseValidationConfig to handle these new sections:

case "unique_b_account_id_2_join_columns" =>
  val Array(sourceId, targetId) = trimmedLine.split(",").map(_.trim)
  validationConfig += ("uniqueBAccountId2SourceId" -> sourceId)
  validationConfig += ("uniqueBAccountId2TargetId" -> targetId)

case "unique_b_account_id_2_transform" =>
  val columns = trimmedLine.split(",").map(_.trim)
  if (columns.length == 3) {
    validationConfig += ("txnDirectionColumnForB2" -> columns(0))
    validationConfig += ("debitColumnForB2" -> columns(1))
    validationConfig += ("creditColumnForB2" -> columns(2))
  } else {
    println(s"Warning: Invalid format for unique B account ID transform - $trimmedLine")
  }

This parsing logic adds the configuration for:
	•	Join columns: uniqueBAccountId2SourceId and uniqueBAccountId2TargetId.
	•	Transformation columns: txnDirectionColumnForB2, debitColumnForB2, and creditColumnForB2.

3. Define the Validation Function

Next, create a function validateBAccountUniqueId2 that:
	•	Joins transactionSource and caseClass on the specified columns.
	•	Creates bAccountUniqueId based on conditions in txn_direction_desc.
	•	Uses exceptAll to find mismatches.
	•	Collects mismatched transactionIds for reporting.

Here’s the function code:

def validateBAccountUniqueId2(sourceDF: DataFrame, targetDF: DataFrame, configMap: Map[String, Any]): Seq[String] = {
  import sourceDF.sparkSession.implicits._

  // Retrieve column names from the configuration
  val sourceId = configMap.getOrElse("uniqueBAccountId2SourceId", "transaction_id").toString
  val targetId = configMap.getOrElse("uniqueBAccountId2TargetId", "transactionId").toString
  val txnDirectionColumn = configMap.getOrElse("txnDirectionColumnForB2", "txn_direction_desc").toString
  val debitColumn = configMap.getOrElse("debitColumnForB2", "COUNTERPARTY_PRODUCT_KEY").toString
  val creditColumn = configMap.getOrElse("creditColumnForB2", "ACCOUNT_KEY").toString

  // Perform the join on the specified ID columns
  val data = sourceDF.join(targetDF, sourceDF(sourceId) === targetDF(targetId), "inner")

  // Apply the conditional transformation to create `bAccountUniqueId`
  val source = data.withColumn("bAccountUniqueId",
    when(col(txnDirectionColumn) === "DEBIT", split(col(debitColumn), "-").getItem(1))
      .otherwise(split(col(creditColumn), "-").getItem(1))
  ).select(col(sourceId).as("transactionId"), $"bAccountUniqueId")

  // Select the target data directly
  val target = targetDF.select($"transactionId", $"bAccountUniqueId")

  // Find mismatches using exceptAll
  val sourceToTargetDiff = source.exceptAll(target)
  val targetToSourceDiff = target.exceptAll(source)

  // Collect transaction IDs for reporting
  val sourceToTargetIds = sourceToTargetDiff.select($"transactionId").as[String].collect()
  val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

  val sourceToTargetCount = sourceToTargetIds.length
  val targetToSourceCount = targetToSourceIds.length

  Seq(
    "B Account Unique ID Validation 2 Differences:",
    s"Source to Target Differences: $sourceToTargetCount found with transaction IDs: " + sourceToTargetIds.mkString(", "),
    s"Target to Source Differences: $targetToSourceCount found with transaction IDs: " + targetToSourceIds.mkString(", ")
  )
}

Explanation

	•	Dynamic Column Retrieval: Uses configMap to fetch the join and transformation column names.
	•	Join Operation: Joins transactionSource and caseClass on the specified ID columns.
	•	Conditional Transformation:
	•	If txn_direction_desc is “DEBIT”, bAccountUniqueId is derived from COUNTERPARTY_PRODUCT_KEY.
	•	Otherwise, bAccountUniqueId is derived from ACCOUNT_KEY.
	•	Comparison with exceptAll:
	•	Finds mismatches between source and target.
	•	Result Formatting:
	•	Collects the mismatched transaction IDs, counts them, and formats the results for reporting.

4. Add the Validation Function to the Main Flow

In your main method, after parsing the configuration, call validateBAccountUniqueId2 and add its output to validationResults:

validationResults = validationResults ++ validateBAccountUniqueId2(transactionSource, caseClass, validationConfigMap)

Example Configuration File

Here’s how to structure your configuration file with this new validation:

[unique_b_account_id_2_join_columns]
transactionSourceId=transaction_id
caseClassId=transactionId

[unique_b_account_id_2_transform]
txnDirectionColumn=txn_direction_desc
debitColumn=COUNTERPARTY_PRODUCT_KEY
creditColumn=ACCOUNT_KEY

Summary

With this setup, the validateBAccountUniqueId2 function will:
	•	Join transactionSource and caseClass on the specified ID columns.
	•	Transform bAccountUniqueId based on txn_direction_desc.
	•	Identify mismatches using exceptAll.
	•	Report mismatched transaction IDs.

This makes the validation adaptable to changes in column names or conditions. Let me know if any additional adjustments are needed!