object CleanseCaseClass {
  def validateAccountType(sourceDF: DataFrame, targetDF: DataFrame, configMap: Map[String, Seq[String]]): Seq[String] = {
    import sourceDF.sparkSession.implicits._

    // Fetch the column names dynamically from the config
    val sourceCols = configMap.getOrElse("account_type_validation_source", Seq())
    val targetCols = configMap.getOrElse("account_type_validation_target", Seq())

    val (alignedSourceCols, alignedTargetCols) = filterExistingColumnPairs(sourceCols, targetCols, sourceDF, targetDF)

    if (alignedSourceCols.nonEmpty && alignedTargetCols.nonEmpty) {
      val sourceData = sourceDF
        .join(targetDF, sourceDF("transaction_id") === targetDF("transactionId"), "inner")
        .withColumn("aAccountType",
          when(substring($"aAccountId", 1, 5).isin("HK100", "HK102", "HK103", "HK400", "HK404", 
                                                        "HKG00", "KEFLX", "KEPRM", "MUBRN", "MUPRM",
                                                        "OBBRN", "SCBRN", "SCVSP", "SH403", "SH404",
                                                        "SHG00") && $"aAccountId".isNotNull, "BANK ACCOUNT")
            .when(substring($"aAccountId", 1, 5).isin("UGFLX", "UGVSP", "UKUBA", "UKUBA", 
                                                      "ZACAR", "ZACHE", "ZACTS", "ZALOA",
                                                      "ZAMID", "ZAMLO", "ZANFD", "ZASAV", 
                                                      "ZATDE", "UKGTS") && $"aAccountId".isNotNull, "BANK ACCOUNT")
            .when(substring($"aAccountId", 1, 5).isin("UKPRM", "UKPSP", "UKTPH", "UKBNC", 
                                                      "UKBNW", "UKBPA", "UKBPF", "UKCAM",
                                                      "UKCML", "PTSP", "ITPSP", "ESPSP") && $"aAccountId".isNotNull, "CREDIT CARD")
            .when(substring($"aAccountId", 1, 5).isin("UKTRN") && $"aAccountId".isNotNull, "MORTGAGE")
            .otherwise(when($"aAccountId".isNotNull, "BANK ACCOUNT").otherwise(null))
        )
        .select($"transaction_id", $"aAccountType")

      val targetData = targetDF
        .select($"transactionId", $"aAccountType")

      // Perform the comparison
      val sourceToTargetDiff = sourceData.except(targetData)
      val targetToSourceDiff = targetData.except(sourceData)

      // Collect mismatched transaction IDs
      val sourceToTargetIds = sourceToTargetDiff.select($"transaction_id").as[String].collect()
      val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

      val sourceToTargetCount = sourceToTargetIds.length
      val targetToSourceCount = targetToSourceIds.length

      Seq(
        "Account Type Validation Differences:",
        s"Source to Target Differences: $sourceToTargetCount found." + sourceToTargetIds.mkString(", "),
        s"Target to Source Differences: $targetToSourceCount found." + targetToSourceIds.mkString(", ")
      )
    } else {
      Seq("Account Type Validation Differences: No relevant columns found for account type validation.")
    }
  }

  // Helper function to filter existing column pairs
  def filterExistingColumnPairs(sourceCols: Seq[String], targetCols: Seq[String], sourceDF: DataFrame, targetDF: DataFrame): (Seq[String], Seq[String]) = {
    val existingSourceCols = sourceCols.filter(sourceDF.columns.contains)
    val existingTargetCols = targetCols.filter(targetDF.columns.contains)
    (existingSourceCols, existingTargetCols)
  }
}








object CleanseCaseClass {
  def validateAccountType(sourceDF: DataFrame, targetDF: DataFrame, configMap: Map[String, Seq[String]]): Seq[String] = {
    import sourceDF.sparkSession.implicits._

    // Fetch the dynamic column names from the config
    val sourceCols = configMap.getOrElse("account_type_validation_source", Seq())
    val targetCols = configMap.getOrElse("account_type_validation_target", Seq())

    // Extract specific column names dynamically
    val transactionIdSourceCol = sourceCols.headOption.getOrElse("transaction_id")
    val aAccountIdCol = if (sourceCols.length > 1) sourceCols(1) else "aAccountId"
    val transactionIdTargetCol = targetCols.headOption.getOrElse("transactionId")
    val aAccountTypeTargetCol = if (targetCols.length > 1) targetCols(1) else "aAccountType"

    // Align column names
    val (alignedSourceCols, alignedTargetCols) = filterExistingColumnPairs(sourceCols, targetCols, sourceDF, targetDF)

    if (alignedSourceCols.nonEmpty && alignedTargetCols.nonEmpty) {
      val sourceData = sourceDF
        .join(targetDF, sourceDF(transactionIdSourceCol) === targetDF(transactionIdTargetCol), "inner")
        .withColumn("aAccountType",
          when(substring(col(aAccountIdCol), 1, 5).isin("HK100", "HK102", "HK103", "HK400", "HK404", 
                                                         "HKG00", "KEFLX", "KEPRM", "MUBRN", "MUPRM",
                                                         "OBBRN", "SCBRN", "SCVSP", "SH403", "SH404",
                                                         "SHG00") && col(aAccountIdCol).isNotNull, "BANK ACCOUNT")
            .when(substring(col(aAccountIdCol), 1, 5).isin("UGFLX", "UGVSP", "UKUBA", "ZACAR", 
                                                           "ZACHE", "ZACTS", "ZALOA",
                                                           "ZAMID", "ZAMLO", "ZANFD", "ZASAV", 
                                                           "ZATDE", "UKGTS") && col(aAccountIdCol).isNotNull, "BANK ACCOUNT")
            .when(substring(col(aAccountIdCol), 1, 5).isin("UKPRM", "UKPSP", "UKTPH", "UKBNC", 
                                                           "UKBNW", "UKBPA", "UKBPF", "UKCAM",
                                                           "UKCML", "PTSP", "ITPSP", "ESPSP") && col(aAccountIdCol).isNotNull, "CREDIT CARD")
            .when(substring(col(aAccountIdCol), 1, 5).isin("UKTRN") && col(aAccountIdCol).isNotNull, "MORTGAGE")
            .otherwise(when(col(aAccountIdCol).isNotNull, "BANK ACCOUNT").otherwise(null))
        )
        .select(col(transactionIdSourceCol), col("aAccountType"))

      val targetData = targetDF
        .select(col(transactionIdTargetCol), col(aAccountTypeTargetCol))

      // Perform the comparison
      val sourceToTargetDiff = sourceData.except(targetData)
      val targetToSourceDiff = targetData.except(sourceData)

      // Collect mismatched transaction IDs
      val sourceToTargetIds = sourceToTargetDiff.select(col(transactionIdSourceCol)).as[String].collect()
      val targetToSourceIds = targetToSourceDiff.select(col(transactionIdTargetCol)).as[String].collect()

      val sourceToTargetCount = sourceToTargetIds.length
      val targetToSourceCount = targetToSourceIds.length

      Seq(
        "Account Type Validation Differences:",
        s"Source to Target Differences: $sourceToTargetCount found." + sourceToTargetIds.mkString(", "),
        s"Target to Source Differences: $targetToSourceCount found." + targetToSourceIds.mkString(", ")
      )
    } else {
      Seq("Account Type Validation Differences: No relevant columns found for account type validation.")
    }
  }

  // Helper function to filter existing column pairs
  def filterExistingColumnPairs(sourceCols: Seq[String], targetCols: Seq[String], sourceDF: DataFrame, targetDF: DataFrame): (Seq[String], Seq[String]) = {
    val existingSourceCols = sourceCols.filter(sourceDF.columns.contains)
    val existingTargetCols = targetCols.filter(targetDF.columns.contains)
    (existingSourceCols, existingTargetCols)
  }
}











object CleanseCaseClass {
  def validateBAccountType(sourceDF: DataFrame, targetDF: DataFrame): Seq[String] = {
    import sourceDF.sparkSession.implicits._

    // Perform the join between sourceDF and targetDF on transaction ID
    val data = sourceDF.join(
      targetDF,
      sourceDF("transaction_id") === targetDF("transactionId"),
      "inner"
    )

    // Add the `bAccountType` column based on logic
    val sourceData = data.withColumn(
      "bAccountType",
      when(
        substring($"aAccountId", 1, 5).isin(
          "HK100", "HK102", "HK103", "HK400", "HK404", "HKG00", "KEFLX", "KEPRM",
          "MUBRN", "MUPRM", "OBBRN", "SCBRN", "SCVSP", "SH403", "SH404", "SHG00"
        ) && $"aAccountId".isNotNull,
        "BANK ACCOUNT"
      )
        .when(
          substring($"aAccountId", 1, 5).isin(
            "UGFLX", "UGVSP", "UKUBA", "ZACAR", "ZACHE", "ZACTS", "ZALOA", "ZAMID",
            "ZAMLO", "ZANFD", "ZASAV", "ZATDE", "UKGTS"
          ) && $"aAccountId".isNotNull,
          "BANK ACCOUNT"
        )
        .when(
          substring($"aAccountId", 1, 5).isin(
            "UKPRM", "UKPSP", "UKTPH", "UKBNC", "UKBNW", "UKBPA", "UKBPF",
            "UKCAM", "UKCML", "PTSP", "ITPSP", "ESPSP"
          ) && $"aAccountId".isNotNull,
          "CREDIT CARD"
        )
        .when(
          substring($"aAccountId", 1, 5).isin("UKTRN") && $"aAccountId".isNotNull,
          "MORTGAGE"
        )
        .otherwise(when($"aAccountId".isNotNull, "BANK ACCOUNT").otherwise(null))
    ).select($"transaction_id", $"bAccountType")

    // Target DataFrame with hardcoded columns
    val targetData = targetDF.select($"transactionId", $"bAccountType")

    // Find differences using exceptAll
    val sourceToTargetDiff = sourceData.exceptAll(targetData)
    val targetToSourceDiff = targetData.exceptAll(sourceData)

    // Collect mismatched transaction IDs
    val sourceToTargetIds = sourceToTargetDiff.select($"transaction_id").as[String].collect()
    val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

    val sourceToTargetCount = sourceToTargetIds.length
    val targetToSourceCount = targetToSourceIds.length

    // Generate result summary
    Seq(
      "bAccountType Validation Differences:",
      s"Source to Target Differences: $sourceToTargetCount found. " + sourceToTargetIds.mkString(", "),
      s"Target to Source Differences: $targetToSourceCount found. " + targetToSourceIds.mkString(", ")
    )
  }
}








object CleanseCaseClass {
  def validateAAccountType(sourceDF: DataFrame, targetDF: DataFrame): Seq[String] = {
    import sourceDF.sparkSession.implicits._

    // Perform the join between sourceDF and targetDF on transaction ID
    val data = sourceDF.join(
      targetDF,
      sourceDF("transaction_id") === targetDF("transactionId"),
      "inner"
    )

    // Add the `aAccountType` column based on the hardcoded logic
    val sourceData = data.withColumn(
      "aAccountType",
      when(
        substring($"aAccountId", 1, 5).isin(
          "HK100", "HK102", "HK103", "HK400", "HK404", "HKG00", "KEFLX", "KEPRM",
          "MUBRN", "MUPRM", "OBBRN", "SCBRN", "SCVSP", "SH403", "SH404", "SHG00"
        ) && $"aAccountId".isNotNull,
        "BANK ACCOUNT"
      )
        .when(
          substring($"aAccountId", 1, 5).isin(
            "UGFLX", "UGVSP", "UKUBA", "ZACAR", "ZACHE", "ZACTS", "ZALOA", "ZAMID",
            "ZAMLO", "ZANFD", "ZASAV", "ZATDE", "UKGTS"
          ) && $"aAccountId".isNotNull,
          "BANK ACCOUNT"
        )
        .when(
          substring($"aAccountId", 1, 5).isin(
            "UKPRM", "UKPSP", "UKTPH", "UKBNC", "UKBNW", "UKBPA", "UKBPF",
            "UKCAM", "UKCML", "PTSP", "ITPSP", "ESPSP"
          ) && $"aAccountId".isNotNull,
          "CREDIT CARD"
        )
        .when(
          substring($"aAccountId", 1, 5).isin("UKTRN") && $"aAccountId".isNotNull,
          "MORTGAGE"
        )
        .otherwise(when($"aAccountId".isNotNull, "BANK ACCOUNT").otherwise(null))
    ).select($"transaction_id", $"aAccountType")

    // Target DataFrame with hardcoded columns
    val targetData = targetDF.select($"transactionId", $"aAccountType")

    // Find differences using exceptAll
    val sourceToTargetDiff = sourceData.exceptAll(targetData)
    val targetToSourceDiff = targetData.exceptAll(sourceData)

    // Collect mismatched transaction IDs
    val sourceToTargetIds = sourceToTargetDiff.select($"transaction_id").as[String].collect()
    val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

    val sourceToTargetCount = sourceToTargetIds.length
    val targetToSourceCount = targetToSourceIds.length

    // Generate result summary
    Seq(
      "aAccountType Validation Differences:",
      s"Source to Target Differences: $sourceToTargetCount found. " + sourceToTargetIds.mkString(", "),
      s"Target to Source Differences: $targetToSourceCount found. " + targetToSourceIds.mkString(", ")
    )
  }
}








object CleanseCaseClass {
  def validateBAccountType(sourceDF: DataFrame, targetDF: DataFrame): Seq[String] = {
    import sourceDF.sparkSession.implicits._

    // Perform the join between sourceDF and targetDF on transaction ID
    val data = sourceDF.join(
      targetDF,
      sourceDF("transaction_id") === targetDF("transactionId"),
      "inner"
    )

    // Add the `bAccountType` column based on the hardcoded logic
    val sourceData = data.withColumn(
      "bAccountType",
      when(
        substring($"bAccountId", 1, 5).isin(
          "HK102", "HK103", "HK400", "HK404", "HKGOO", "KEFLX", "KEPRM", "MUBRN",
          "MUPRM", "OBBRN", "SCBRN", "SCVSP", "SH403", "SH404", "SHG00"
        ) && $"bAccountId".isNotNull,
        "BANK ACCOUNT"
      )
        .when(
          substring($"bAccountId", 1, 5).isin(
            "UGFLX", "UGVSP", "UKUBA", "ZACAR", "ZACHE", "ZACTS", "ZALOA", "ZAMID",
            "ZAMLO", "ZANFD", "ZASAV", "ZATDE", "UKGTS"
          ) && $"bAccountId".isNotNull,
          "BANK ACCOUNT"
        )
        .when(
          substring($"bAccountId", 1, 5).isin(
            "UKPRM", "UKPSP", "UKTPH", "UKBNC", "UKCML", "PTPSP", "ITPSP", "ESPSP"
          ) && $"bAccountId".isNotNull,
          "CREDIT CARD"
        )
        .when(
          substring($"bAccountId", 1, 5).isin("UKTRN") && $"bAccountId".isNotNull,
          "MORTGAGE"
        )
        .otherwise(when($"bAccountId".isNotNull, "BANK ACCOUNT").otherwise(null))
    ).select($"transaction_id", $"bAccountType")

    // Target DataFrame with hardcoded columns
    val targetData = targetDF.select($"transactionId", $"bAccountType")

    // Find differences using exceptAll
    val sourceToTargetDiff = sourceData.exceptAll(targetData)
    val targetToSourceDiff = targetData.exceptAll(sourceData)

    // Collect mismatched transaction IDs
    val sourceToTargetIds = sourceToTargetDiff.select($"transaction_id").as[String].collect()
    val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

    val sourceToTargetCount = sourceToTargetIds.length
    val targetToSourceCount = targetToSourceIds.length

    // Generate result summary
    Seq(
      "bAccountType Validation Differences:",
      s"Source to Target Differences: $sourceToTargetCount found. " + sourceToTargetIds.mkString(", "),
      s"Target to Source Differences: $targetToSourceCount found. " + targetToSourceIds.mkString(", ")
    )
  }
}






object CleanseCaseClass {
  def validateASortCode(sourceDF: DataFrame, targetDF: DataFrame): Seq[String] = {
    import sourceDF.sparkSession.implicits._

    // Perform the join between sourceDF and targetDF on transaction ID
    val data = sourceDF.join(
      targetDF,
      sourceDF("transaction_id") === targetDF("transactionId"),
      "inner"
    )

    // Add the `aAccountId` column logic
    val sourceData = data.withColumn(
      "aAccountId",
      when(
        $"txn_direction_desc".isin("DEBIT") &&
          substring($"aAccountId", 1, 5).isin("UKUBA", "UKGTS"),
        substring($"aAccountId", 17, 6)
      ).otherwise(null)
    ).select($"transaction_id", $"aAccountId")

    // Target DataFrame with hardcoded columns
    val targetData = targetDF.select($"transactionId", $"aSortCode")

    // Find differences using exceptAll
    val sourceToTargetDiff = sourceData.exceptAll(targetData)
    val targetToSourceDiff = targetData.exceptAll(sourceData)

    // Collect mismatched transaction IDs
    val sourceToTargetIds = sourceToTargetDiff.select($"transaction_id").as[String].collect()
    val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

    val sourceToTargetCount = sourceToTargetIds.length
    val targetToSourceCount = targetToSourceIds.length

    // Generate result summary
    Seq(
      "aSortCode Validation Differences:",
      s"Source to Target Differences: $sourceToTargetCount found. " + sourceToTargetIds.mkString(", "),
      s"Target to Source Differences: $targetToSourceCount found. " + targetToSourceIds.mkString(", ")
    )
  }
}








object CleanseCaseClass {
  def validateBSortCode(sourceDF: DataFrame, targetDF: DataFrame): Seq[String] = {
    import sourceDF.sparkSession.implicits._

    // Perform the join between sourceDF and targetDF on transaction ID
    val data = sourceDF.join(
      targetDF,
      sourceDF("transaction_id") === targetDF("transactionId"),
      "inner"
    )

    // Add the `bAccountId` column logic
    val sourceData = data.withColumn(
      "bAccountId",
      when(
        $"txn_direction_desc".isin("DEBIT") &&
          substring($"bAccountId", 1, 5).isin("UKUBA", "UKGTS"),
        substring($"bAccountId", 17, 6)
      ).otherwise(null)
    ).select($"transaction_id", $"bAccountId")

    // Target DataFrame with hardcoded columns
    val targetData = targetDF.select($"transactionId", $"bSortCode")

    // Find differences using exceptAll
    val sourceToTargetDiff = sourceData.exceptAll(targetData)
    val targetToSourceDiff = targetData.exceptAll(sourceData)

    // Collect mismatched transaction IDs
    val sourceToTargetIds = sourceToTargetDiff.select($"transaction_id").as[String].collect()
    val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

    val sourceToTargetCount = sourceToTargetIds.length
    val targetToSourceCount = targetToSourceIds.length

    // Generate result summary
    Seq(
      "bSortCode Validation Differences:",
      s"Source to Target Differences: $sourceToTargetCount found. " + sourceToTargetIds.mkString(", "),
      s"Target to Source Differences: $targetToSourceCount found. " + targetToSourceIds.mkString(", ")
    )
  }
}





object CleanseCaseClass {
  def validateAmountGbp(sourceDF: DataFrame, targetDF: DataFrame): Seq[String] = {
    import sourceDF.sparkSession.implicits._

    // Source DataFrame with hardcoded columns
    val sourceData = sourceDF.select($"transaction_id", $"sterling_equivalent")

    // Target DataFrame with hardcoded columns
    val targetData = targetDF.select($"transactionId", $"amountGbp")

    // Find differences using exceptAll
    val sourceToTargetDiff = sourceData.exceptAll(targetData)
    val targetToSourceDiff = targetData.exceptAll(sourceData)

    // Collect mismatched transaction IDs
    val sourceToTargetIds = sourceToTargetDiff.select($"transaction_id").as[String].collect()
    val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

    val sourceToTargetCount = sourceToTargetIds.length
    val targetToSourceCount = targetToSourceIds.length

    // Generate result summary
    Seq(
      "amountGbp Validation Differences:",
      s"Source to Target Differences: $sourceToTargetCount found. " + sourceToTargetIds.mkString(", "),
      s"Target to Source Differences: $targetToSourceCount found. " + targetToSourceIds.mkString(", ")
    )
  }
}




object CleanseCaseClass {
  def validateAggregatedTransactionId(sourceDF: DataFrame, targetDF: DataFrame): Seq[String] = {
    import sourceDF.sparkSession.implicits._

    // Source DataFrame with calculated `aggregatedTransactionId`
    val sourceData = sourceDF.withColumn(
      "aggregatedTransactionId",
      concat(col("aAccountUniqueId"), lit("//"), col("bAccountUniqueId"))
    ).select($"transactionId", $"aggregatedTransactionId")

    // Target DataFrame with hardcoded columns
    val targetData = targetDF.select($"transactionId", $"aggregatedTransactionId")

    // Find differences using exceptAll
    val sourceToTargetDiff = sourceData.exceptAll(targetData)
    val targetToSourceDiff = targetData.exceptAll(sourceData)

    // Collect mismatched transaction IDs
    val sourceToTargetIds = sourceToTargetDiff.select($"transactionId").as[String].collect()
    val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

    val sourceToTargetCount = sourceToTargetIds.length
    val targetToSourceCount = targetToSourceIds.length

    // Generate result summary
    Seq(
      "aggregatedTransactionId Validation Differences:",
      s"Source to Target Differences: $sourceToTargetCount found. " + sourceToTargetIds.mkString(", "),
      s"Target to Source Differences: $targetToSourceCount found. " + targetToSourceIds.mkString(", ")
    )
  }
}



object CleanseCaseClass {
  def validateAggregatedTransactionDocumentType(sourceDF: DataFrame, targetDF: DataFrame): Seq[String] = {
    import sourceDF.sparkSession.implicits._

    // Source DataFrame with calculated `aggregatedTransactionDocumentType`
    val sourceData = sourceDF.withColumn(
      "aggregatedTransactionDocumentType",
      when($"aggregatedTransactionId".isNotNull, "transaction").otherwise(null)
    ).select($"transactionId", $"aggregatedTransactionDocumentType")

    // Target DataFrame with hardcoded columns
    val targetData = targetDF.select($"transactionId", $"aggregatedTransactionDocumentType")

    // Find differences using exceptAll
    val sourceToTargetDiff = sourceData.exceptAll(targetData)
    val targetToSourceDiff = targetData.exceptAll(sourceData)

    // Collect mismatched transaction IDs
    val sourceToTargetIds = sourceToTargetDiff.select($"transactionId").as[String].collect()
    val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

    val sourceToTargetCount = sourceToTargetIds.length
    val targetToSourceCount = targetToSourceIds.length

    // Generate result summary
    Seq(
      "aggregatedTransactionDocumentType Validation Differences:",
      s"Source to Target Differences: $sourceToTargetCount found. " + sourceToTargetIds.mkString(", "),
      s"Target to Source Differences: $targetToSourceCount found. " + targetToSourceIds.mkString(", ")
    )
  }
}













