To set up the configuration in this format, we can adjust the parsing logic so that each component (source, target, and mapping) is handled as a separate section in the config file. Here’s how you can achieve this:

Updated Configuration File Format

In your configuration file, you can structure the transaction_country_iso3_validation section like this:

[transaction_country_iso3_validation_source]
TRANSACTION_COUNTRY_ISO_CODE

[transaction_country_iso3_validation_target]
transactionCountryIso3

[mapping]
AD:AND, AE:ARE, AF:AFG, ...

Updated Code

We’ll need to:
	1.	Adjust the parseValidationConfig function to recognize these different sections.
	2.	Modify validateTransactionCountryIso3 to use the parsed configuration sections.

Step 1: Modify parseValidationConfig

Here’s an updated parseValidationConfig function to handle the new format:

def parseIso3Mapping(config: String): Map[String, String] = {
  config.split(",").map { pair =>
    val Array(code2, code3) = pair.split(":")
    code2.trim -> code3.trim
  }.toMap
}

def parseValidationConfig(configPath: String, sparkSession: SparkSession): Map[String, Any] = {
  import sparkSession.implicits._
  var currentSection = ""
  var validationConfig = Map[String, Any]()

  sparkSession.read.text(configPath).as[String].collect().foreach { line =>
    val trimmedLine = line.trim
    if (trimmedLine.startsWith("[") && trimmedLine.endsWith("]")) {
      currentSection = trimmedLine.substring(1, trimmedLine.length - 1)
    } else if (trimmedLine.nonEmpty && currentSection.nonEmpty) {
      currentSection match {
        case "transaction_country_iso3_validation_source" =>
          validationConfig += ("sourceColumn" -> trimmedLine)
        case "transaction_country_iso3_validation_target" =>
          validationConfig += ("targetColumn" -> trimmedLine)
        case "mapping" =>
          validationConfig += ("iso3Mapping" -> parseIso3Mapping(trimmedLine))
        case _ => // Handle other sections as needed
      }
    }
  }
  validationConfig
}

Explanation

	•	Section Detection: Each section header (e.g., [transaction_country_iso3_validation_source]) is stored in currentSection.
	•	Conditional Parsing:
	•	If currentSection is transaction_country_iso3_validation_source, it sets "sourceColumn" to the column name.
	•	If currentSection is transaction_country_iso3_validation_target, it sets "targetColumn" to the target column name.
	•	If currentSection is mapping, it parses the country code mappings into a Map[String, String].

Step 2: Modify validateTransactionCountryIso3 Function

Now, use the parsed configuration in validateTransactionCountryIso3:

def validateTransactionCountryIso3(sourceDF: DataFrame, targetDF: DataFrame, configMap: Map[String, Any]): Seq[String] = {
  import sourceDF.sparkSession.implicits._

  // Retrieve config settings for this validation
  val sourceColumn = configMap.getOrElse("sourceColumn", "TRANSACTION_COUNTRY_ISO_CODE").toString
  val targetColumn = configMap.getOrElse("targetColumn", "transactionCountryIso3").toString
  val mapping = configMap.getOrElse("iso3Mapping", Map.empty[String, String]).asInstanceOf[Map[String, String]]

  // Define the mapping UDF dynamically based on configuration
  val mappingUDF = udf((input: String) => mapping.getOrElse(input, input))

  // Apply the mapping UDF to create a new column with the mapped ISO3 code
  val resultDF = sourceDF.withColumn("newISO3", mappingUDF(col(sourceColumn)))
    .select($"TRANSACTION_ID", $"newISO3")

  // Select target data
  val targetData = targetDF.select($"transactionId", col(targetColumn))

  // Find mismatches using exceptAll
  val sourceToTargetDiff = resultDF.exceptAll(targetData)
  val targetToSourceDiff = targetData.exceptAll(resultDF)

  // Collect transaction IDs for reporting
  val sourceToTargetIds = sourceToTargetDiff.select($"TRANSACTION_ID").as[String].collect()
  val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

  val sourceToTargetCount = sourceToTargetIds.length
  val targetToSourceCount = targetToSourceIds.length

  Seq(
    "Transaction Country ISO3 Validation Differences:",
    s"Source to Target Differences: $sourceToTargetCount found with transaction IDs: " + sourceToTargetIds.mkString(", "),
    s"Target to Source Differences: $targetToSourceCount found with transaction IDs: " + targetToSourceIds.mkString(", ")
  )
}

Explanation of Changes in validateTransactionCountryIso3

	•	Dynamic Columns: Uses sourceColumn and targetColumn retrieved from the config for flexibility.
	•	Dynamic Mapping UDF: The mappingUDF now uses the dynamically parsed Map[String, String] from the config, allowing you to manage all mappings within the configuration file.

Step 3: Call the Validation Function

Finally, call validateTransactionCountryIso3 from your main method, passing transactionSource, caseClass, and validationConfigMap:

validationResults = validationResults ++ validateTransactionCountryIso3(transactionSource, caseClass, validationConfigMap)

This setup makes the validation flexible, allowing you to configure column names and mappings directly in the configuration file. Expand the mapping in the config as needed to include all country codes. Let me know if this meets your requirements or if you need further assistance!