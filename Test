import com.amazonaws.services.glue.GlueContext
import com.amazonaws.services.glue.util.Job
import org.apache.spark.SparkContext
import org.apache.spark.sql.{SparkSession, DataFrame}
import org.apache.spark.sql.functions._
import com.amazonaws.services.glue.util.GlueArgParser
import java.io.{File, PrintWriter}

object CleanseCaseClass {

  def main(sysArgs: Array[String]): Unit = {
    val glueContext: GlueContext = new GlueContext(SparkContext.getOrCreate())
    val spark: SparkSession = glueContext.getSparkSession
    import spark.implicits._

    // Logger
    val logger = org.apache.log4j.Logger.getLogger("CleanseCaseClassLogger")

    // Read job parameters
    val args = GlueArgParser.getResolvedOptions(sysArgs, Seq("s3ConfigPath").toArray)
    val s3ConfigPath = args("s3ConfigPath")
    val configMap = spark.read.textFile(s3ConfigPath).collect().map { line =>
      val split = line.split("=")
      (split(0).trim, split(1).trim)
    }.toMap

    val inputSourcePath = configMap("inputSourcePath")
    val inputTargetPath = configMap("inputTargetPath")
    val outputBasePath = configMap("outputBasePath")

    val transactionSource: DataFrame = spark.read.parquet(inputSourcePath)
    val caseClass: DataFrame = spark.read.parquet(inputTargetPath)

    val outputFile = new File(s"$outputBasePath/validation_differences.txt")
    val writer = new PrintWriter(outputFile)

    // Null Validation
    val targetNullColumns = configMap("null_validation_columns").split(",").map(_.trim)
    val nullDifferences = targetNullColumns.flatMap { col =>
      caseClass.filter(col(col).isNotNull).select("transactionid").as[String].collect()
    }
    writer.write("Null Validation Differences:\n")
    writer.write(nullDifferences.mkString(", ") + "\n\n")

    // Direct Column Validation
    val sourceCols = configMap("direct_column_validation_columns_source").split(",").map(_.trim)
    val targetCols = configMap("direct_column_validation_columns_target").split(",").map(_.trim)
    val (existingSourceCols, existingTargetCols) = filterExistingColumnPairs(sourceCols, targetCols, transactionSource, caseClass)
    
    val directSourceToTargetDiff = transactionSource.select(existingSourceCols.map(col): _*).exceptAll(caseClass.select(existingTargetCols.map(col): _*))
    val directTargetToSourceDiff = caseClass.select(existingTargetCols.map(col): _*).exceptAll(transactionSource.select(existingSourceCols.map(col): _*))

    val sourceToTargetDiffIds = directSourceToTargetDiff.select("TRANSACTION_ID").as[String].collect()
    val targetToSourceDiffIds = directTargetToSourceDiff.select("transactionid").as[String].collect()

    writer.write("Direct Column Validation Differences:\n")
    writer.write("Source to Target Differences: " + sourceToTargetDiffIds.mkString(", ") + "\n")
    writer.write("Target to Source Differences: " + targetToSourceDiffIds.mkString(", ") + "\n\n")

    // Narrative Validation
    val sourceNarrativeCol = configMap("narrative_validation_column_source")
    val targetNarrativeCol = configMap("narrative_validation_column_target")

    val sourceNarrative = transactionSource.select($"TRANSACTION_ID", col(sourceNarrativeCol).as("narrative"))
    val targetNarrative = caseClass.select($"transactionid", col(targetNarrativeCol).as("narrative"))

    val narrativeSourceToTargetDiff = sourceNarrative.exceptAll(targetNarrative)
    val narrativeTargetToSourceDiff = targetNarrative.exceptAll(sourceNarrative)

    val narrativeSourceToTargetIds = narrativeSourceToTargetDiff.select("TRANSACTION_ID").as[String].collect()
    val narrativeTargetToSourceIds = narrativeTargetToSourceDiff.select("transactionid").as[String].collect()

    writer.write("Narrative Validation Differences:\n")
    writer.write("Source to Target Differences: " + narrativeSourceToTargetIds.mkString(", ") + "\n")
    writer.write("Target to Source Differences: " + narrativeTargetToSourceIds.mkString(", ") + "\n\n")

    // Amount Local Validation
    val sourceAmountCol = configMap("amount_local_validation_column_source")
    val targetAmountCol = configMap("amount_local_validation_column_target")

    val sourceAmount = transactionSource.select($"TRANSACTION_ID", col(sourceAmountCol).as("amount"))
    val targetAmount = caseClass.select($"transactionid", col(targetAmountCol).as("amount"))

    val amountSourceToTargetDiff = sourceAmount.exceptAll(targetAmount)
    val amountTargetToSourceDiff = targetAmount.exceptAll(sourceAmount)

    val amountSourceToTargetIds = amountSourceToTargetDiff.select("TRANSACTION_ID").as[String].collect()
    val amountTargetToSourceIds = amountTargetToSourceDiff.select("transactionid").as[String].collect()

    writer.write("Amount Local Validation Differences:\n")
    writer.write("Source to Target Differences: " + amountSourceToTargetIds.mkString(", ") + "\n")
    writer.write("Target to Source Differences: " + amountTargetToSourceIds.mkString(", ") + "\n\n")

    // Transaction Country ISO3 Validation
    val sourceCountryCol = configMap("transaction_country_iso3_validation_column_source")
    val targetCountryCol = configMap("transaction_country_iso3_validation_column_target")

    val sourceCountry = transactionSource.select($"TRANSACTION_ID", col(sourceCountryCol).as("country"))
    val targetCountry = caseClass.select($"transactionid", col(targetCountryCol).as("country"))

    val countrySourceToTargetDiff = sourceCountry.exceptAll(targetCountry)
    val countryTargetToSourceDiff = targetCountry.exceptAll(sourceCountry)

    val countrySourceToTargetIds = countrySourceToTargetDiff.select("TRANSACTION_ID").as[String].collect()
    val countryTargetToSourceIds = countryTargetToSourceDiff.select("transactionid").as[String].collect()

    writer.write("Transaction Country ISO3 Validation Differences:\n")
    writer.write("Source to Target Differences: " + countrySourceToTargetIds.mkString(", ") + "\n")
    writer.write("Target to Source Differences: " + countryTargetToSourceIds.mkString(", ") + "\n\n")

    writer.close()
    Job.commit()
  }

  // Helper function for existing column pairs
  def filterExistingColumnPairs(sourceColumns: Seq[String], targetColumns: Seq[String], sourceDF: DataFrame, targetDF: DataFrame): (Seq[String], Seq[String]) = {
    val existingSourceCols = sourceColumns.filter(sourceDF.columns.contains)
    val existingTargetCols = targetColumns.filter(targetDF.columns.contains)
    (existingSourceCols, existingTargetCols)
  }
}