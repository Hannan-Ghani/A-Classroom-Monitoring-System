Certainly! Here’s a breakdown of the three distinct validations, each with its own configuration, parsing logic, and validation function.

1. Sterling Equivalent Validation

This validation checks for differences between sterling_equivalent in transactionSource and amountGbp in caseClass.

Configuration

[sterling_equivalent_validation]
sourceColumn=sterling_equivalent
targetColumn=amountGbp

Parsing Logic

Add this case to parseValidationConfig:

case "sterling_equivalent_validation" =>
  validationConfig += ("sterlingEquivalentSourceColumn" -> configMap("sourceColumn").trim)
  validationConfig += ("sterlingEquivalentTargetColumn" -> configMap("targetColumn").trim)

Validation Function: validateSterlingEquivalent

def validateSterlingEquivalent(sourceDF: DataFrame, targetDF: DataFrame, configMap: Map[String, Any]): Seq[String] = {
  import sourceDF.sparkSession.implicits._

  val sourceColumn = configMap("sterlingEquivalentSourceColumn").toString
  val targetColumn = configMap("sterlingEquivalentTargetColumn").toString

  val source = sourceDF.select($"transaction_id".as("transactionId"), col(sourceColumn).as("sterlingEquivalent"))
  val target = targetDF.select($"transactionId", col(targetColumn).as("sterlingEquivalent"))

  val sourceToTargetDiff = source.exceptAll(target)
  val targetToSourceDiff = target.exceptAll(source)

  val sourceToTargetIds = sourceToTargetDiff.select($"transactionId").as[String].collect()
  val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

  Seq(
    "Sterling Equivalent Validation Differences:",
    s"Source to Target Differences: ${sourceToTargetIds.length} found with transaction IDs: ${sourceToTargetIds.mkString(", ")}",
    s"Target to Source Differences: ${targetToSourceIds.length} found with transaction IDs: ${targetToSourceIds.mkString(", ")}"
  )
}

2. Aggregated Transaction Document Type Validation

This validation sets aggregatedTransactionDocumentType to “transaction” if aggregatedTransactionId is not null and compares the transformed data with caseClass.

Configuration

[aggregated_transaction_document_type_validation]
sourceColumn=aggregatedTransactionId
documentTypeColumn=aggregatedTransactionDocumentType
documentTypeValue=transaction

Parsing Logic

Add this case to parseValidationConfig:

case "aggregated_transaction_document_type_validation" =>
  validationConfig += ("aggregatedTransactionSourceColumn" -> configMap("sourceColumn").trim)
  validationConfig += ("aggregatedTransactionDocumentTypeColumn" -> configMap("documentTypeColumn").trim)
  validationConfig += ("aggregatedTransactionDocumentTypeValue" -> configMap("documentTypeValue").trim)

Validation Function: validateAggregatedTransactionDocumentType

def validateAggregatedTransactionDocumentType(sourceDF: DataFrame, targetDF: DataFrame, configMap: Map[String, Any]): Seq[String] = {
  import sourceDF.sparkSession.implicits._

  val sourceColumn = configMap("aggregatedTransactionSourceColumn").toString
  val documentTypeColumn = configMap("aggregatedTransactionDocumentTypeColumn").toString
  val documentTypeValue = configMap("aggregatedTransactionDocumentTypeValue").toString

  val source = sourceDF.withColumn(documentTypeColumn,
    when(col(sourceColumn).isNotNull, documentTypeValue).otherwise(null)
  ).select($"transaction_id".as("transactionId"), col(documentTypeColumn))

  val target = targetDF.select($"transactionId", col(documentTypeColumn))

  val sourceToTargetDiff = source.exceptAll(target)
  val targetToSourceDiff = target.exceptAll(source)

  val sourceToTargetIds = sourceToTargetDiff.select($"transactionId").as[String].collect()
  val targetToSourceIds = targetToSourceDiff.select($"transactionId").as[String].collect()

  Seq(
    "Aggregated Transaction Document Type Validation Differences:",
    s"Source to Target Differences: ${sourceToTargetIds.length} found with transaction IDs: ${sourceToTargetIds.mkString(", ")}",
    s"Target to Source Differences: ${targetToSourceIds.length} found with transaction IDs: ${targetToSourceIds.mkString(", ")}"
  )
}

3. Aggregated Transaction ID Distinct Validation

This validation checks for distinct values of aggregatedTransactionId in caseClass.

Configuration

[aggregated_transaction_id_validation]
column=aggregatedTransactionId

Parsing Logic

Add this case to parseValidationConfig:

case "aggregated_transaction_id_validation" =>
  validationConfig += ("aggregatedTransactionIdColumn" -> configMap("column").trim)

Validation Function: validateAggregatedTransactionIdDistinct

def validateAggregatedTransactionIdDistinct(targetDF: DataFrame, configMap: Map[String, Any]): Seq[String] = {
  val aggregatedTransactionIdColumn = configMap("aggregatedTransactionIdColumn").toString

  val distinctIds = targetDF.select(aggregatedTransactionIdColumn).distinct().collect().map(_.getString(0))

  Seq(
    s"Distinct Aggregated Transaction IDs in $aggregatedTransactionIdColumn:",
    distinctIds.mkString(", ")
  )
}

Step 4: Integrate All Functions into the Main Flow

In your main method, after parsing the configuration, call each validation function:

validationResults = validationResults ++ validateSterlingEquivalent(transactionSource, caseClass, validationConfigMap)
validationResults = validationResults ++ validateAggregatedTransactionDocumentType(transactionSource, caseClass, validationConfigMap)
validationResults = validationResults ++ validateAggregatedTransactionIdDistinct(caseClass, validationConfigMap)

Complete Example Configuration File

Here’s how your configuration file might look with all sections:

[sterling_equivalent_validation]
sourceColumn=sterling_equivalent
targetColumn=amountGbp

[aggregated_transaction_document_type_validation]
sourceColumn=aggregatedTransactionId
documentTypeColumn=aggregatedTransactionDocumentType
documentTypeValue=transaction

[aggregated_transaction_id_validation]
column=aggregatedTransactionId

Summary

With this setup:
	•	validateSterlingEquivalent compares sterling_equivalent with amountGbp.
	•	validateAggregatedTransactionDocumentType checks if aggregatedTransactionId is not null and assigns “transaction” to aggregatedTransactionDocumentType.
	•	validateAggregatedTransactionIdDistinct checks for distinct aggregatedTransactionId values in caseClass.

Each validation is now clearly separated and integrated into the main validation flow. Let me know if you need further customization!