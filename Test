import com.amazonaws.services.glue.GlueContext
import com.amazonaws.services.glue.util.Job
import org.apache.spark.SparkContext
import org.apache.spark.sql.{DataFrame, SparkSession}
import com.amazonaws.services.glue.util.GlueArgParser
import org.apache.spark.sql.functions._
import org.apache.log4j.Logger

object CleanseCaseClass {

  def main(sysArgs: Array[String]): Unit = {
    // Initialize Glue and Spark context
    val spark: SparkContext = new SparkContext()
    val glueContext: GlueContext = new GlueContext(spark)
    val sparkSession: SparkSession = glueContext.getSparkSession
    import sparkSession.implicits._

    // Setup Logger
    val logger: Logger = Logger.getLogger("CleanseCaseClassLogger")

    // Read configuration file paths from Glue job parameters
    val args = GlueArgParser.getResolvedOptions(sysArgs, Seq("s3ConfigPath", "s3ColumnsConfigPath", "outputSummaryPath").toArray)
    val s3ConfigPath = args("s3ConfigPath")
    val s3ColumnsConfigPath = args("s3ColumnsConfigPath")
    val outputSummaryPath = args("outputSummaryPath")

    // ==============================
    // STEP 1: Load Configurations
    // ==============================
    // Helper function to read configuration file from S3
    def readConfigFromS3(s3Path: String): Map[String, String] = {
      val configDF = sparkSession.read.text(s3Path)
      configDF.collect().map { row =>
        val split = row.getString(0).split("=")
        (split(0).trim, split(1).trim)
      }.toMap
    }

    // Read paths and column configurations
    val configMap = readConfigFromS3(s3ConfigPath)
    val columnConfig = readConfigFromS3(s3ColumnsConfigPath)

    val inputSourcePath = configMap("inputSourcePath")
    val inputTargetPath = configMap("inputTargetPath")
    val outputBasePath = configMap("outputBasePath")

    // ==============================
    // STEP 2: Load Data from S3
    // ==============================
    val transactionSource: DataFrame = sparkSession.read.parquet(inputSourcePath)
    val caseClass: DataFrame = sparkSession.read.parquet(inputTargetPath)

    // Initialize validation summary
    var validationSummary = "Validation Results Summary:\n"

    // ==============================
    // Country Code Mapping UDF
    // ==============================
    // Map 2-letter country codes to ISO3 codes
    val countryCodeMapping = Map(
      "US" -> "USA", "CA" -> "CAN", "MX" -> "MEX", "GB" -> "GBR", "FR" -> "FRA",
      "DE" -> "DEU", "IN" -> "IND", "CN" -> "CHN", "JP" -> "JPN", "AU" -> "AUS"
    )
    val mapCountryCodeUDF = udf((code: String) => countryCodeMapping.getOrElse(code, code))

    // ==============================
    // STEP 3: Null Value Validation
    // ==============================
    val nullColumns = columnConfig.getOrElse("null_validation.columns", "").split(",").map(_.trim).toSeq
    val existingNullColumns = nullColumns.filter(caseClass.columns.contains)

    val nullValidationCount = caseClass.filter(row => existingNullColumns.exists(col => row.getAs[Any](col) == null)).count()
    validationSummary += s"Null Validation: $nullValidationCount found\n"

    // ==============================
    // STEP 4: Direct Column Validation (Source-to-Target and Target-to-Source)
    // ==============================
    val sourceDirectColumns = columnConfig.getOrElse("direct_column_validation.columns_source", "").split(",").map(_.trim).toSeq
    val targetDirectColumns = columnConfig.getOrElse("direct_column_validation.columns_target", "").split(",").map(_.trim).toSeq

    val directSourceData = transactionSource.select(sourceDirectColumns.map(col): _*)
    val directTargetData = caseClass.select(targetDirectColumns.map(col): _*)
    val directSourceToTargetDiff = directSourceData.exceptAll(directTargetData)
    val directTargetToSourceDiff = directTargetData.exceptAll(directSourceData)

    val directSourceToTargetCount = directSourceToTargetDiff.count()
    val directTargetToSourceCount = directTargetToSourceDiff.count()
    val directSourceToTargetIds = directSourceToTargetDiff.select("TRANSACTION_ID").as[String].collect().mkString(", ")
    val directTargetToSourceIds = directTargetToSourceDiff.select("transactionId").as[String].collect().mkString(", ")

    validationSummary += s"Direct Column Validation: ${directSourceToTargetCount + directTargetToSourceCount} found\n"
    validationSummary += s"Source to Target Transaction IDs: $directSourceToTargetIds\n"
    validationSummary += s"Target to Source Transaction IDs: $directTargetToSourceIds\n"

    // ==============================
    // STEP 5: Country ISO3 Validation (Source-to-Target and Target-to-Source with Country Mapping)
    // ==============================
    val sourceCountryColumn = columnConfig.getOrElse("transaction_country_iso3_validation.source_column", "")
    val targetCountryColumn = columnConfig.getOrElse("transaction_country_iso3_validation.target_column", "")

    val sourceCountryData = transactionSource
      .withColumn("isoCountryCodeMapped", mapCountryCodeUDF(col(sourceCountryColumn)))
      .select($"TRANSACTION_ID", $"isoCountryCodeMapped")

    val targetCountryData = caseClass.select($"transactionId", col(targetCountryColumn).as("isoCountryCode"))

    val countrySourceToTargetDiff = sourceCountryData.exceptAll(targetCountryData)
    val countryTargetToSourceDiff = targetCountryData.exceptAll(sourceCountryData.select($"TRANSACTION_ID", $"isoCountryCodeMapped"))

    val countrySourceToTargetCount = countrySourceToTargetDiff.count()
    val countryTargetToSourceCount = countryTargetToSourceDiff.count()
    val countrySourceToTargetIds = countrySourceToTargetDiff.select("TRANSACTION_ID").as[String].collect().mkString(", ")
    val countryTargetToSourceIds = countryTargetToSourceDiff.select("transactionId").as[String].collect().mkString(", ")

    validationSummary += s"Country ISO3 Validation: ${countrySourceToTargetCount + countryTargetToSourceCount} found\n"
    validationSummary += s"Source to Target Transaction IDs: $countrySourceToTargetIds\n"
    validationSummary += s"Target to Source Transaction IDs: $countryTargetToSourceIds\n"

    // ==============================
    // STEP 6: Write Validation Summary to S3 as Text File
    // ==============================
    val outputSummaryDF = Seq(validationSummary).toDF("Validation_Summary")
    outputSummaryDF.coalesce(1).write.mode("overwrite").text(outputSummaryPath)

    // Commit the Glue job
    Job.commit()
  }
}